<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Manager - ClickDescubra 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .status {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .status-icon.loading {
            background: #ffc107;
        }

        .status-icon.success {
            background: #28a745;
        }

        .status-icon.error {
            background: #dc3545;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4facfe;
        }

        .question-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #4facfe;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-input input[type="radio"] {
            width: auto;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 90, 82, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(64, 192, 87, 0.4);
        }

        .questions-list {
            display: grid;
            gap: 20px;
        }

        .question-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s;
        }

        .question-card:hover {
            border-color: #4facfe;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .question-header {
            display: flex;
            justify-content: between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .question-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            flex-grow: 1;
            margin-right: 15px;
        }

        .question-meta {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        .question-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .option {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .option.correct {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .option.incorrect {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            color: #495057;
        }

        .question-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
        }

        .group-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }

        .group-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #495057;
        }

        .group-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffa726 0%, #fb8c00 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(251, 140, 0, 0.4);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            color: #4facfe;
            border-bottom-color: #4facfe;
        }

        .tab:hover {
            color: #4facfe;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .image-upload-group {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: border-color 0.3s;
        }

        .image-upload-group:hover,
        .image-upload-group.dragover {
            border-color: #4facfe;
            background-color: #f8f9ff;
        }

        .image-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .image-upload-btn {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 5px;
        }

        .image-remove-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }

        .question-image {
            max-width: 200px;
            max-height: 150px;
            border-radius: 6px;
            margin: 10px 0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .no-image-placeholder {
            color: #999;
            font-style: italic;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 6px;
            margin: 10px 0;
        }

        /* Group Storage Progress Bars */
        .storage-item {
            margin-bottom: 20px;
        }

        .storage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .storage-group-name {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .storage-size-info {
            font-size: 13px;
            color: #666;
        }

        .storage-bar-container {
            height: 24px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .storage-bar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.3s ease, background 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }

        .storage-bar.low {
            background: linear-gradient(90deg, #51cf66 0%, #40c057 100%);
        }

        .storage-bar.medium {
            background: linear-gradient(90deg, #ffd43b 0%, #ffc107 100%);
        }

        .storage-bar.high {
            background: linear-gradient(90deg, #ff8787 0%, #ff6b6b 100%);
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            background: white;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .loading-content .loading-spinner {
            width: 40px;
            height: 40px;
            border-width: 4px;
            margin: 0 auto 15px auto;
        }

        .loading-content p {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #495057;
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p id="loadingMessage">Salvando...</p>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üéØ Quiz Manager</h1>
            <p>Gerencie as perguntas do ClickDescubra 2025</p>
        </div>

        <div class="status">
            <div class="status-item">
                <div class="status-icon loading" id="statusIcon"></div>
                <span id="statusText">Carregando...</span>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn btn-success" onclick="loadQuestions()">
                    üîÑ Recarregar
                </button>
                <button class="btn btn-primary" onclick="downloadAllImages()">
                    üì• Exportar Imagens
                </button>
            </div>
        </div>

        <!-- Tabs no topo -->
        <div class="tabs" style="border-bottom: 2px solid #e9ecef; background: white;">
            <button class="tab active" onclick="switchTab('groups')">üìÇ Grupos</button>
            <button class="tab" onclick="switchTab('questions')">üìù Perguntas</button>
            <button class="tab" onclick="switchTab('schedule')">‚è∞ Agendamento</button>
            <button class="tab" onclick="switchTab('ranking')">üèÜ Ranking</button>
            <button class="tab" onclick="switchTab('config')">‚öôÔ∏è Configura√ß√µes</button>
        </div>

        <div class="main-content">
            <!-- Alert Messages (global) -->
            <div id="alertContainer"></div>

            <!-- Groups Tab -->
            <div id="groupsTab" class="tab-content active">
                <!-- Stats (apenas na aba de grupos) -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="totalGroups">0</div>
                        <div class="stat-label">Total de Grupos</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalQuestions">0</div>
                        <div class="stat-label">Total de Perguntas</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="categoriesCount">0</div>
                        <div class="stat-label">Categorias</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="avgTime">0s</div>
                        <div class="stat-label">Tempo M√©dio</div>
                    </div>
                </div>

                <!-- Add/Edit Group Form -->
                <div class="section">
                    <h2 class="section-title" id="groupFormTitle">‚ûï Adicionar Novo Grupo</h2>
                    <div class="question-form">
                        <div class="form-group">
                            <label for="groupName">Nome do Grupo (opcional):</label>
                            <input type="text" id="groupName" placeholder="Deixe vazio para usar 'Grupo X'">
                            <small style="color: #666;">Se deixar vazio, ser√° usado "Grupo 1", "Grupo 2", etc.</small>
                        </div>

                        <div class="form-group">
                            <label for="groupIntroMessage">Mensagem de Apresenta√ß√£o:</label>
                            <textarea id="groupIntroMessage" placeholder="Mensagem exibida ANTES de iniciar este grupo..."></textarea>
                            <small style="color: #666;">Aparece na tela de transi√ß√£o antes de come√ßar as perguntas do grupo.</small>
                        </div>

                        <div class="form-group">
                            <label for="groupMessage">Mensagem de Conclus√£o:</label>
                            <textarea id="groupMessage" placeholder="Mensagem exibida ao completar este grupo..."></textarea>
                            <small style="color: #666;">Aparece na tela de transi√ß√£o ap√≥s completar todas as perguntas.</small>
                        </div>

                        <div id="groupFormActions">
                            <button class="btn btn-primary" onclick="addGroup()">
                                ‚ûï Adicionar Grupo
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Groups List -->
                <div class="section">
                    <h2 class="section-title">üìÇ Grupos Existentes (m√°ximo 6)</h2>
                    <div id="groupsList">
                        <!-- Groups will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Questions Tab -->
            <div id="questionsTab" class="tab-content">
                <!-- Add/Edit Question Form -->
                <div class="section">
                    <h2 class="section-title" id="formTitle">‚ûï Adicionar Nova Pergunta</h2>
                <div class="question-form">
                    <div class="form-group">
                        <label for="questionText">Pergunta:</label>
                        <textarea id="questionText" placeholder="Digite sua pergunta aqui..."></textarea>
                    </div>

                    <div class="form-group">
                        <label>Imagem da Pergunta (opcional):</label>
                        <div class="image-upload-group" id="imageUploadArea">
                            <div id="imagePreviewContainer">
                                <p>üñºÔ∏è Clique para adicionar uma imagem ou arraste aqui</p>
                                <input type="file" id="questionImage" accept="image/*" style="display: none;">
                                <button type="button" class="image-upload-btn"
                                    onclick="document.getElementById('questionImage').click()">
                                    üìé Escolher Imagem
                                </button>
                            </div>
                        </div>
                        <small style="color: #666;">Formatos aceitos: JPG, PNG, GIF. Tamanho m√°ximo: 2MB</small>
                    </div>

                    <div class="form-group">
                        <label>Op√ß√µes de Resposta:</label>
                        <div class="options-grid">
                            <div class="option-input">
                                <input type="radio" name="correctOption" value="0" id="correct0">
                                <input type="text" id="option0" placeholder="Op√ß√£o 1">
                            </div>
                            <div class="option-input">
                                <input type="radio" name="correctOption" value="1" id="correct1">
                                <input type="text" id="option1" placeholder="Op√ß√£o 2">
                            </div>
                            <div class="option-input">
                                <input type="radio" name="correctOption" value="2" id="correct2">
                                <input type="text" id="option2" placeholder="Op√ß√£o 3">
                            </div>
                            <div class="option-input">
                                <input type="radio" name="correctOption" value="3" id="correct3">
                                <input type="text" id="option3" placeholder="Op√ß√£o 4">
                            </div>
                        </div>
                        <small style="color: #666;">Selecione o bot√£o de r√°dio da resposta correta</small>
                    </div>

                    <div class="form-group">
                        <label for="questionGroup">Grupo:</label>
                        <select id="questionGroup">
                            <option value="">Selecione um grupo...</option>
                        </select>
                        <small style="color: #666;">Selecione em qual grupo esta pergunta pertence</small>
                    </div>

                    <div class="form-group">
                        <label for="category">Categoria:</label>
                        <input type="text" id="category" placeholder="Ex: Geografia, Hist√≥ria, Ci√™ncias...">
                    </div>

                    <div class="form-group">
                        <label for="timeSeconds">Tempo (segundos):</label>
                        <input type="number" id="timeSeconds" value="150" min="5" max="300">
                    </div>

                    <!-- Alert Messages locais (para valida√ß√£o) -->
                    <div id="questionFormAlertContainer"></div>

                    <div id="formActions">
                        <button class="btn btn-primary" onclick="addQuestion()">
                            ‚ûï Adicionar Pergunta
                        </button>
                    </div>
                </div>
            </div>

                <!-- Questions List -->
                <div class="section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 class="section-title" style="margin: 0;">üìù Perguntas Existentes</h2>
                        <div class="form-group" style="margin: 0; width: 300px;">
                            <label for="filterGroup" style="margin-bottom: 5px;">Filtrar por Grupo:</label>
                            <select id="filterGroup" onchange="filterQuestionsByGroup()">
                                <option value="">Todos os Grupos</option>
                            </select>
                        </div>
                    </div>
                    <div id="questionsList" class="questions-list">
                        <!-- Questions will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Schedule Tab -->
            <div id="scheduleTab" class="tab-content">
                <div class="section">
                    <h2 class="section-title">‚è∞ Agendamento do Quiz</h2>
                    <div class="question-form">
                        <p style="margin-bottom: 20px; color: #666;">
                            Configure o per√≠odo em que o quiz estar√° dispon√≠vel para os jogadores.
                            Deixe os campos vazios para o quiz estar sempre dispon√≠vel.
                        </p>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div class="form-group">
                                <label for="startDate">üìÖ Data de In√≠cio:</label>
                                <input type="date" id="startDate">
                            </div>
                            <div class="form-group">
                                <label for="startTime">üïê Hora de In√≠cio:</label>
                                <input type="time" id="startTime">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div class="form-group">
                                <label for="endDate">üìÖ Data de T√©rmino:</label>
                                <input type="date" id="endDate">
                            </div>
                            <div class="form-group">
                                <label for="endTime">üïê Hora de T√©rmino:</label>
                                <input type="time" id="endTime">
                            </div>
                        </div>

                        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <strong>Status Atual:</strong>
                            <div id="scheduleStatus" style="margin-top: 10px; font-size: 16px;">
                                Carregando...
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-success" onclick="saveSchedule()">
                                üíæ Salvar Agendamento
                            </button>
                            <button class="btn btn-warning" onclick="clearSchedule()">
                                üóëÔ∏è Remover Agendamento (sempre dispon√≠vel)
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ranking Tab -->
            <div id="rankingTab" class="tab-content">
                <div class="section">
                    <h2 class="section-title">üèÜ Ranking dos Jogadores</h2>

                    <div style="margin-bottom: 20px; display: flex; gap: 10px;">
                        <button class="btn btn-success" onclick="loadRanking()">
                            üîÑ Recarregar Ranking
                        </button>
                        <button class="btn btn-primary" onclick="exportRankingToCSV()">
                            üì• Exportar para CSV
                        </button>
                    </div>

                    <div style="overflow-x: auto;">
                        <table id="rankingTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 10px; overflow: hidden;">
                            <thead style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <tr>
                                    <th style="padding: 15px; text-align: left;">üèÖ Coloca√ß√£o</th>
                                    <th style="padding: 15px; text-align: left;">üë§ Nome</th>
                                    <th style="padding: 15px; text-align: left;">üìß Email</th>
                                    <th style="padding: 15px; text-align: left;">üì± Telefone</th>
                                    <th style="padding: 15px; text-align: left;">üíº Cargo</th>
                                    <th style="padding: 15px; text-align: center;">üéØ Pontua√ß√£o</th>
                                    <th style="padding: 15px; text-align: center;">‚è±Ô∏è Tempo</th>
                                </tr>
                            </thead>
                            <tbody id="rankingTableBody">
                                <tr>
                                    <td colspan="7" style="text-align: center; padding: 40px; color: #666;">
                                        Carregando ranking...
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div id="rankingStats" style="margin-top: 30px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <!-- Stats cards will be added here -->
                    </div>
                </div>
            </div>

            <!-- Config Tab -->
            <div id="configTab" class="tab-content">
                <div class="section">
                    <h2 class="section-title">‚öôÔ∏è Configura√ß√µes de API</h2>

                    <div style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4caf50;">
                        <strong>‚úÖ Usando JSONBin.io Pro</strong>
                        <p style="margin: 10px 0 0 0; line-height: 1.6;">
                            O sistema est√° configurado para usar o <strong>JSONBin.io com plano Pro</strong>, que oferece:
                        </p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li>‚úÖ Sem limites de tamanho de payload (suporta imagens base64)</li>
                            <li>‚úÖ Funciona perfeitamente no gerenciador web e Unity</li>
                            <li>‚úÖ Alta disponibilidade e backup autom√°tico</li>
                            <li>‚úÖ API r√°pida e confi√°vel</li>
                        </ul>
                        <p style="margin: 10px 0 0 0; color: #666; font-size: 14px;">
                            <strong>Nota:</strong> A op√ß√£o de servidor customizado est√° dispon√≠vel como backup, mas n√£o √© necess√°ria.
                        </p>
                    </div>

                    <div class="question-form">
                        <p style="margin-bottom: 20px; color: #666;">
                            Configure qual servidor ser√° usado para armazenar os dados do quiz.
                        </p>

                        <div class="form-group">
                            <label><strong>Tipo de API:</strong></label>
                            <div style="display: flex; gap: 20px; margin-top: 10px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="apiType" value="jsonbin" checked onchange="toggleAPIConfig()">
                                    <span style="margin-left: 8px;">üì¶ JSONBin.io Pro (Recomendado)</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="apiType" value="customServer" onchange="toggleAPIConfig()">
                                    <span style="margin-left: 8px;">üåê Servidor Customizado (Backup)</span>
                                </label>
                            </div>
                        </div>

                        <!-- JSONBin Config -->
                        <div id="jsonbinConfig" style="margin-top: 30px;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üì¶ Configura√ß√µes JSONBin.io Pro</h3>

                            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <strong>‚ú® Plano Pro Ativo</strong>
                                <p style="margin: 8px 0 0 0; font-size: 14px; color: #666;">
                                    Sem limites de tamanho, suporta imagens base64, alta disponibilidade.
                                </p>
                            </div>

                            <div class="form-group">
                                <label>API Key:</label>
                                <input type="text" id="jsonbinApiKey" value="$2a$10$Uu3NdRpmfPSc0b2MNV0PY.mKluWPCevjK7ioHlXr4AlMca/HC2V9y" readonly style="background: #f5f5f5;">
                            </div>

                            <div class="form-group">
                                <label>Quiz Bin ID:</label>
                                <input type="text" id="jsonbinQuizBinId" value="68e7598543b1c97be95fbb4d" readonly style="background: #f5f5f5;">
                            </div>

                            <div class="form-group">
                                <label>Ranking Bin ID:</label>
                                <input type="text" id="jsonbinRankingBinId" value="68e75972ae596e708f0b701f" readonly style="background: #f5f5f5;">
                            </div>

                            <div class="form-group">
                                <label>Registration Bin ID:</label>
                                <input type="text" id="jsonbinRegistrationBinId" value="68ed827aae596e708f1217dc" readonly style="background: #f5f5f5;">
                            </div>

                            <!-- Group Storage Usage -->
                            <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                                <h3 style="color: #667eea; margin-bottom: 20px;">üíæ Uso de Espa√ßo por Grupo</h3>
                                <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                    Cada grupo tem um bin separado com limite de 1 MB para armazenar imagens.
                                </p>

                                <div id="groupStorageStats">
                                    <!-- Progress bars will be dynamically generated here -->
                                    <div style="color: #999; text-align: center; padding: 20px;">
                                        Carregue um quiz para ver o uso de espa√ßo
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Custom Server Config -->
                        <div id="customServerConfig" style="margin-top: 30px; display: none;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üåê Configura√ß√µes Servidor Customizado</h3>

                            <div class="form-group">
                                <label>Base URL:</label>
                                <input type="text" id="customBaseUrl" value="https://jogos.clickideia.com.br" placeholder="https://seu-servidor.com">
                            </div>

                            <div class="form-group">
                                <label>Quiz Endpoint:</label>
                                <input type="text" id="customQuizEndpoint" value="/QuizData.php" placeholder="/QuizData.php">
                            </div>

                            <div class="form-group">
                                <label>Ranking Endpoint:</label>
                                <input type="text" id="customRankingEndpoint" value="/Ranking.php" placeholder="/Ranking.php">
                            </div>

                            <div class="form-group">
                                <label>Registration Endpoint:</label>
                                <input type="text" id="customRegistrationEndpoint" value="/Register.php" placeholder="/Register.php">
                            </div>

                            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #ffc107;">
                                <strong>‚ö†Ô∏è Requisitos do Servidor Customizado:</strong>
                                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                                    <li><strong>M√©todos HTTP:</strong> GET e POST</li>
                                    <li><strong>Arquivos JSON:</strong> Devem existir e ser acess√≠veis publicamente</li>
                                    <li><strong>CORS (Critical!):</strong> Configurar headers no servidor:
                                        <ul style="margin-top: 5px;">
                                            <li><code>Access-Control-Allow-Origin: *</code></li>
                                            <li><code>Access-Control-Allow-Methods: GET, POST, OPTIONS</code></li>
                                            <li><code>Access-Control-Allow-Headers: Content-Type</code></li>
                                        </ul>
                                    </li>
                                    <li><strong>Para Unity:</strong> CORS n√£o √© necess√°rio (apenas para web)</li>
                                </ul>
                                <p style="margin: 10px 0 0 0; padding: 10px; background: #fff; border-radius: 4px; font-size: 13px;">
                                    <strong>üí° Dica:</strong> Se voc√™ vir erro "blocked by CORS policy" no console, significa que o servidor n√£o est√° configurado corretamente.
                                    A aplica√ß√£o Unity n√£o ter√° esse problema, apenas o gerenciador web.
                                </p>
                            </div>
                        </div>

                        <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                            <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                                <h4 style="margin: 0 0 10px 0; color: #1976d2;">üìã Configura√ß√£o Atual:</h4>
                                <div id="currentConfig" style="font-family: monospace; font-size: 14px; color: #666;">
                                    Carregando...
                                </div>
                            </div>

                            <button class="btn btn-primary" style="font-size: 18px; padding: 15px; width: 100%; margin-bottom: 15px;" onclick="applyConfigAndReload()">
                                üîÑ Aplicar Configura√ß√£o Agora
                            </button>

                            <button class="btn btn-warning" style="font-size: 16px; padding: 12px; width: 100%; margin-bottom: 20px;" onclick="quickSwitchToJSONBin()">
                                ‚ö° Voltar R√°pido para JSONBin.io
                            </button>

                            <div style="padding: 15px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4caf50;">
                                <strong>üöÄ Como Funciona:</strong>
                                <ol style="margin: 10px 0 0 20px; line-height: 1.8;">
                                    <li>Escolha o tipo de API (JSONBin ou Servidor Customizado)</li>
                                    <li>Configure as URLs se necess√°rio</li>
                                    <li>Clique em "üîÑ Aplicar Configura√ß√£o Agora"</li>
                                    <li><strong>Web:</strong> Passa a usar as novas URLs imediatamente (GET/POST)</li>
                                    <li><strong>Unity:</strong> O navegador vai pedir para salvar o arquivo <code>api-config.json</code></li>
                                    <li>Salve o arquivo em: <code>Build/StreamingAssets/api-config.json</code></li>
                                    <li>Pronto! Unity ler√° na pr√≥xima vez que abrir</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dynamic API Configuration - Can be changed via config tab
        let API_CONFIG = {
            apiType: 'jsonbin', // 'jsonbin' or 'customServer'
            jsonbin: {
                apiKey: '$2a$10$Uu3NdRpmfPSc0b2MNV0PY.mKluWPCevjK7ioHlXr4AlMca/HC2V9y',
                baseUrl: 'https://api.jsonbin.io/v3/b',
                quizBinId: '68e7598543b1c97be95fbb4d',
                rankingBinId: '68e75972ae596e708f0b701f',
                registrationBinId: '68ed827aae596e708f1217dc',
                group1ImagesBinId: '6906ba3e43b1c97be99255f0',
                group2ImagesBinId: '6906ba51d0ea881f40cd502c',
                group3ImagesBinId: '6906ba5dd0ea881f40cd504c',
                group4ImagesBinId: '6906ba63ae596e708f3e0ec2',
                group5ImagesBinId: '6906ba6bd0ea881f40cd5071',
                group6ImagesBinId: '6906ec45d0ea881f40cdde91'
            },
            customServer: {
                baseUrl: 'https://jogos.clickideia.com.br',
                quizEndpoint: '/QuizData.php',
                rankingEndpoint: '/Ranking.php',
                registrationEndpoint: '/Register.php'
            }
        };

        // Helper functions to get URLs based on current config
        function getQuizURL() {
            if (API_CONFIG.apiType === 'jsonbin') {
                return `${API_CONFIG.jsonbin.baseUrl}/${API_CONFIG.jsonbin.quizBinId}/latest`;
            } else {
                return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.quizEndpoint}`;
            }
        }

        function getRankingURL() {
            if (API_CONFIG.apiType === 'jsonbin') {
                return `${API_CONFIG.jsonbin.baseUrl}/${API_CONFIG.jsonbin.rankingBinId}/latest`;
            } else {
                return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.rankingEndpoint}`;
            }
        }

        function getRegistrationURL() {
            if (API_CONFIG.apiType === 'jsonbin') {
                return `${API_CONFIG.jsonbin.baseUrl}/${API_CONFIG.jsonbin.registrationBinId}/latest`;
            } else {
                return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.registrationEndpoint}`;
            }
        }

        function getRequestHeaders(isUpdate = false) {
            const headers = {};
            if (API_CONFIG.apiType === 'jsonbin') {
                headers['X-Master-Key'] = API_CONFIG.jsonbin.apiKey;
                headers['Accept'] = 'application/json';
                headers['X-Bin-Meta'] = 'false';
                if (isUpdate) {
                    headers['Content-Type'] = 'application/json';
                }
            } else {
                headers['Content-Type'] = 'application/json';
                headers['Accept'] = 'application/json';
            }
            return headers;
        }

        function getUpdateURL(type) {
            if (API_CONFIG.apiType === 'jsonbin') {
                let binId;
                if (type === 'quiz') binId = API_CONFIG.jsonbin.quizBinId;
                else if (type === 'ranking') binId = API_CONFIG.jsonbin.rankingBinId;
                else if (type === 'registration') binId = API_CONFIG.jsonbin.registrationBinId;
                return `${API_CONFIG.jsonbin.baseUrl}/${binId}`;
            } else {
                if (type === 'quiz') return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.quizEndpoint}`;
                else if (type === 'ranking') return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.rankingEndpoint}`;
                else if (type === 'registration') return `${API_CONFIG.customServer.baseUrl}${API_CONFIG.customServer.registrationEndpoint}`;
            }
        }

        let quizData = null;
        let editingQuestionId = null;
        let editingGroupId = null;
        let currentImageData = null; // { base64, dataUrl, mimeType, filename, originalName }
        let imageRemoved = false;
        let currentTab = 'groups';
        let currentFilterGroupId = '';

        // Image handling functions
        function setupImageUpload() {
            const imageInput = document.getElementById('questionImage');
            const uploadArea = document.getElementById('imageUploadArea');

            // File input change event
            imageInput.addEventListener('change', handleImageUpload);

            // Drag and drop events
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleImageFile(files[0]);
                }
            });
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }

        function handleImageFile(file) {
            // Validate file type
            if (!file.type.startsWith('image/')) {
                showAlert('Por favor, selecione apenas arquivos de imagem.', 'error');
                return;
            }

            // Show loading message
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = '<p style="color: #666;">‚è≥ Processando e comprimindo imagem...</p>';

            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    // Compress image to reduce size
                    compressImage(img, file.name, file.type)
                        .then(compressed => {
                            // Verificar se adicionar essa imagem vai estourar o limite
                            const currentPayloadSize = JSON.stringify(quizData).length;
                            const newImageSize = compressed.base64.length;
                            const estimatedTotalSize = currentPayloadSize + newImageSize;
                            const estimatedTotalMB = (estimatedTotalSize / 1024 / 1024).toFixed(2);
                            const maxSafeSizeMB = 8;

                            console.log(`üìä Tamanho atual do payload: ${(currentPayloadSize / 1024 / 1024).toFixed(2)} MB`);
                            console.log(`üì¶ Tamanho da nova imagem: ${compressed.sizeKB} KB`);
                            console.log(`üìà Tamanho estimado total: ${estimatedTotalMB} MB`);

                            // Se estourar o limite, bloquear o upload
                            if (estimatedTotalSize > (maxSafeSizeMB * 1024 * 1024)) {
                                console.error(`‚ùå BLOQUEADO: Adicionar esta imagem ultrapassaria o limite de ${maxSafeSizeMB} MB`);
                                showAlert(
                                    `‚ùå IMAGEM BLOQUEADA\n\n` +
                                    `Esta imagem n√£o pode ser adicionada pois ultrapassaria o limite de dados.\n\n` +
                                    `Tamanho atual: ${(currentPayloadSize / 1024 / 1024).toFixed(2)} MB\n` +
                                    `Tamanho da imagem: ${compressed.sizeKB} KB\n` +
                                    `Total estimado: ${estimatedTotalMB} MB\n` +
                                    `Limite: ${maxSafeSizeMB} MB\n\n` +
                                    `Sugest√µes:\n` +
                                    `‚Ä¢ Remova algumas imagens existentes\n` +
                                    `‚Ä¢ Use uma imagem de menor resolu√ß√£o\n` +
                                    `‚Ä¢ Salve o quiz antes de adicionar mais imagens`,
                                    'error'
                                );

                                // Resetar o preview para o estado inicial
                                removeImage();
                                return;
                            }

                            // Tudo OK, adicionar a imagem
                            // Gerar imageId √∫nico para o novo sistema de bins separados
                            currentImageData = {
                                ...compressed,
                                imageId: 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
                            };
                            imageRemoved = false;
                            showImagePreview(currentImageData.dataUrl);

                            console.log(`‚úÖ Imagem adicionada com sucesso: ${compressed.sizeKB} KB (ID: ${currentImageData.imageId})`);

                            // Avisar se a imagem ficou grande
                            if (compressed.sizeKB > 400) {
                                showAlert(`‚ö†Ô∏è Imagem comprimida: ${compressed.sizeKB} KB\n\nA imagem foi comprimida ao m√°ximo poss√≠vel, mas ainda ficou relativamente grande.`, 'warning');
                            }
                        })
                        .catch(error => {
                            // Falha na compress√£o - imagem muito grande
                            console.error('‚ùå Erro ao comprimir imagem:', error);
                            showAlert(error.message || 'Erro ao processar imagem.', 'error');

                            // Resetar o preview para o estado inicial
                            removeImage();
                        });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function compressImage(img, originalName, mimeType) {
            return new Promise((resolve, reject) => {
                // Tentar redu√ß√£o progressiva com diferentes configura√ß√µes
                const compressionSettings = [
                    { maxSize: 800, quality: 0.7, label: 'Padr√£o (800px, 70%)' },
                    { maxSize: 600, quality: 0.6, label: 'M√©dia (600px, 60%)' },
                    { maxSize: 400, quality: 0.5, label: 'Alta (400px, 50%)' },
                    { maxSize: 300, quality: 0.4, label: 'M√°xima (300px, 40%)' }
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const outputMimeType = 'image/jpeg';
                let bestResult = null;

                for (let i = 0; i < compressionSettings.length; i++) {
                    const settings = compressionSettings[i];
                    let width = img.width;
                    let height = img.height;

                    // Redimensionar se for muito grande
                    if (width > settings.maxSize || height > settings.maxSize) {
                        if (width > height) {
                            height = (height / width) * settings.maxSize;
                            width = settings.maxSize;
                        } else {
                            width = (width / height) * settings.maxSize;
                            height = settings.maxSize;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    const dataUrl = canvas.toDataURL(outputMimeType, settings.quality);
                    const base64Data = dataUrl.split(',')[1];
                    const sizeKB = Math.round((base64Data.length * 3) / 4 / 1024);

                    console.log(`üîÑ Tentativa ${i + 1}: ${settings.label} = ${sizeKB} KB`);

                    // Se ficou com tamanho aceit√°vel (menos de 400 KB), usar este
                    if (sizeKB <= 400) {
                        console.log(`‚úÖ Compress√£o bem-sucedida: ${sizeKB} KB`);
                        bestResult = {
                            filename: generateImageFilename(originalName),
                            base64: base64Data,
                            dataUrl: dataUrl,
                            mimeType: outputMimeType,
                            originalName: originalName,
                            sizeKB: sizeKB
                        };
                        resolve(bestResult);
                        return;
                    }

                    // Guardar o melhor resultado at√© agora
                    if (!bestResult || sizeKB < bestResult.sizeKB) {
                        bestResult = {
                            filename: generateImageFilename(originalName),
                            base64: base64Data,
                            dataUrl: dataUrl,
                            mimeType: outputMimeType,
                            originalName: originalName,
                            sizeKB: sizeKB
                        };
                    }
                }

                // Se chegou aqui, nenhuma configura√ß√£o deixou a imagem pequena o suficiente
                // Mas vamos verificar se o melhor resultado √© aceit√°vel (menos de 600 KB)
                if (bestResult && bestResult.sizeKB <= 600) {
                    console.log(`‚ö†Ô∏è Imagem comprimida com sucesso, mas ficou maior que o ideal: ${bestResult.sizeKB} KB`);
                    resolve(bestResult);
                } else {
                    console.error(`‚ùå Imagem muito grande mesmo ap√≥s todas as tentativas: ${bestResult ? bestResult.sizeKB : 'N/A'} KB`);
                    reject({
                        message: `Imagem muito grande (${bestResult ? bestResult.sizeKB : 'N/A'} KB). O tamanho m√°ximo recomendado √© 600 KB.\n\nPor favor, use uma imagem menor ou de menor resolu√ß√£o.`,
                        sizeKB: bestResult ? bestResult.sizeKB : null
                    });
                }
            });
        }

        function generateImageFilename(originalName) {
            const extension = originalName.split('.').pop();
            return `question_${Date.now()}.${extension}`;
        }

        function showImagePreview(imageSrc) {
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = `
                <img src="${imageSrc}" alt="Preview" class="image-preview">
                <br>
                <input type="file" id="questionImage" accept="image/*" style="display: none;">
                <button type="button" class="image-upload-btn" onclick="document.getElementById('questionImage').click()">
                    üîÑ Trocar Imagem
                </button>
                <button type="button" class="image-remove-btn" onclick="removeImage()">
                    üóëÔ∏è Remover
                </button>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    ${currentImageData.originalName}
                </p>
            `;
            // Reattach event listener to the new input
            document.getElementById('questionImage').addEventListener('change', handleImageUpload);
        }

        function removeImage() {
            currentImageData = null;
            imageRemoved = true;
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = `
                <p>üñºÔ∏è Clique para adicionar uma imagem ou arraste aqui</p>
                <input type="file" id="questionImage" accept="image/*" style="display: none;">
                <button type="button" class="image-upload-btn" onclick="document.getElementById('questionImage').click()">
                    üìé Escolher Imagem
                </button>
            `;
            // Reattach event listener
            document.getElementById('questionImage').addEventListener('change', handleImageUpload);
        }

        function buildDataUrl(base64, mimeType = 'image/png') {
            if (!base64) return null;
            return `data:${mimeType};base64,${base64}`;
        }

        function getExtensionFromMime(mimeType) {
            if (!mimeType) return 'png';

            const normalized = mimeType.toLowerCase();
            if (normalized.includes('jpeg') || normalized.includes('jpg')) return 'jpg';
            if (normalized.includes('png')) return 'png';
            if (normalized.includes('gif')) return 'gif';
            if (normalized.includes('bmp')) return 'bmp';
            if (normalized.includes('webp')) return 'webp';
            return 'png';
        }

        function normalizeLegacyImage(question) {
            if (!question) return;

            // Already in new format
            if (question.imageBase64) {
                question.imageMimeType = question.imageMimeType || 'image/png';
                if (!question.imageFilename && question.imageOriginalName) {
                    const extension = question.imageOriginalName.split('.').pop();
                    question.imageFilename = `question_${question.id || Date.now()}.${extension || 'png'}`;
                }
                return;
            }

            if (question.image) {
                const legacyData = question.image.data || question.image.originalData || question.image.base64;
                if (legacyData) {
                    const base64 = legacyData.includes(',') ? legacyData.split(',')[1] : legacyData;
                    let mimeType = question.image.mimeType;

                    if (!mimeType && typeof legacyData === 'string' && legacyData.startsWith('data:')) {
                        const semiIndex = legacyData.indexOf(';');
                        if (semiIndex > 5) {
                            mimeType = legacyData.substring(5, semiIndex);
                        }
                    }

                    question.imageBase64 = base64;
                    question.imageMimeType = mimeType || 'image/png';
                    question.imageOriginalName = question.image.originalName || question.image.filename || question.imageFilename || 'imagem.png';

                    if (!question.imageFilename) {
                        const legacyFilename = question.image.filename || '';
                        const legacyOriginal = question.imageOriginalName || legacyFilename;
                        const inferredExtension = legacyFilename ? legacyFilename.split('.').pop()
                            : legacyOriginal ? legacyOriginal.split('.').pop()
                                : getExtensionFromMime(question.imageMimeType);

                        question.imageFilename = `question_${question.id || Date.now()}.${inferredExtension || getExtensionFromMime(question.imageMimeType)}`;
                    }
                }

                delete question.image;
            }
        }

        // Tab switching
        function switchTab(tabName) {
            currentTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            if (tabName === 'groups') {
                document.getElementById('groupsTab').classList.add('active');
            } else if (tabName === 'questions') {
                document.getElementById('questionsTab').classList.add('active');
            } else if (tabName === 'schedule') {
                document.getElementById('scheduleTab').classList.add('active');
            } else if (tabName === 'ranking') {
                document.getElementById('rankingTab').classList.add('active');
                loadRanking(); // Carregar ranking ao abrir a aba
            } else if (tabName === 'config') {
                document.getElementById('configTab').classList.add('active');
                updateCurrentConfigDisplay();
                updateGroupStorageStats(); // Atualizar barras de progresso
            }
        }

        // Config Tab Functions
        function toggleAPIConfig() {
            const selectedType = document.querySelector('input[name="apiType"]:checked').value;

            if (selectedType === 'jsonbin') {
                document.getElementById('jsonbinConfig').style.display = 'block';
                document.getElementById('customServerConfig').style.display = 'none';
            } else {
                document.getElementById('jsonbinConfig').style.display = 'none';
                document.getElementById('customServerConfig').style.display = 'block';
            }

            updateCurrentConfigDisplay();
        }

        function updateCurrentConfigDisplay() {
            const selectedType = document.querySelector('input[name="apiType"]:checked').value;
            const configDiv = document.getElementById('currentConfig');

            let configText = '';
            if (selectedType === 'jsonbin') {
                configText = `
API Type: JSONBin.io
Quiz URL: ${API_CONFIG.jsonbin.baseUrl}/${document.getElementById('jsonbinQuizBinId').value}/latest
Ranking URL: ${API_CONFIG.jsonbin.baseUrl}/${document.getElementById('jsonbinRankingBinId').value}/latest
Registration URL: ${API_CONFIG.jsonbin.baseUrl}/${document.getElementById('jsonbinRegistrationBinId').value}/latest
                `.trim();
            } else {
                const baseUrl = document.getElementById('customBaseUrl').value;
                const quizEndpoint = document.getElementById('customQuizEndpoint').value;
                const rankingEndpoint = document.getElementById('customRankingEndpoint').value;
                const registrationEndpoint = document.getElementById('customRegistrationEndpoint').value;

                configText = `
API Type: Servidor Customizado
Quiz URL: ${baseUrl}${quizEndpoint}
Ranking URL: ${baseUrl}${rankingEndpoint}
Registration URL: ${baseUrl}${registrationEndpoint}
                `.trim();
            }

            configDiv.textContent = configText;
        }

        function quickSwitchToJSONBin() {
            // Marcar radio button JSONBin
            document.querySelector('input[name="apiType"][value="jsonbin"]').checked = true;
            toggleAPIConfig();

            // Aplicar configura√ß√£o
            API_CONFIG.apiType = 'jsonbin';

            console.log('‚ö° Voltando para JSONBin.io...');
            showAlert('‚ö° Voltando para JSONBin.io...', 'success');

            // Recarregar dados
            setTimeout(() => {
                loadQuestions();
                if (currentTab === 'ranking') {
                    loadRanking();
                }
            }, 500);
        }

        async function applyConfigAndReload() {
            const selectedType = document.querySelector('input[name="apiType"]:checked').value;

            // Atualizar configura√ß√£o global
            API_CONFIG.apiType = selectedType;

            // Atualizar valores do JSONBin (se foram editados)
            API_CONFIG.jsonbin.apiKey = document.getElementById('jsonbinApiKey').value;
            API_CONFIG.jsonbin.quizBinId = document.getElementById('jsonbinQuizBinId').value;
            API_CONFIG.jsonbin.rankingBinId = document.getElementById('jsonbinRankingBinId').value;
            API_CONFIG.jsonbin.registrationBinId = document.getElementById('jsonbinRegistrationBinId').value;

            // Atualizar valores do Custom Server
            API_CONFIG.customServer.baseUrl = document.getElementById('customBaseUrl').value;
            API_CONFIG.customServer.quizEndpoint = document.getElementById('customQuizEndpoint').value;
            API_CONFIG.customServer.rankingEndpoint = document.getElementById('customRankingEndpoint').value;
            API_CONFIG.customServer.registrationEndpoint = document.getElementById('customRegistrationEndpoint').value;

            console.log('‚úÖ Configura√ß√£o atualizada:', API_CONFIG);

            showAlert('‚úÖ Configura√ß√£o aplicada! Recarregando dados...', 'success');

            // Recarregar todos os dados com a nova configura√ß√£o
            setTimeout(() => {
                loadQuestions();
                if (currentTab === 'ranking') {
                    loadRanking();
                }
            }, 500);
        }

        async function saveConfigToFile() {
            const config = {
                apiType: API_CONFIG.apiType,
                jsonbin: {
                    apiKey: API_CONFIG.jsonbin.apiKey,
                    baseUrl: API_CONFIG.jsonbin.baseUrl,
                    quizBinId: API_CONFIG.jsonbin.quizBinId,
                    rankingBinId: API_CONFIG.jsonbin.rankingBinId,
                    registrationBinId: API_CONFIG.jsonbin.registrationBinId
                },
                customServer: {
                    baseUrl: API_CONFIG.customServer.baseUrl,
                    quizEndpoint: API_CONFIG.customServer.quizEndpoint,
                    rankingEndpoint: API_CONFIG.customServer.rankingEndpoint,
                    registrationEndpoint: API_CONFIG.customServer.registrationEndpoint
                }
            };

            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });

            try {
                // Tentar usar File System Access API (Chrome moderno)
                if ('showSaveFilePicker' in window) {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'api-config.json',
                        types: [{
                            description: 'JSON Config File',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });

                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    console.log('‚úÖ Arquivo salvo via File System Access API');
                    showAlert('üíæ Arquivo salvo! Coloque em: Build/StreamingAssets/api-config.json', 'success');
                } else {
                    // Fallback: download autom√°tico
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'api-config.json';
                    link.click();
                    URL.revokeObjectURL(url);

                    console.log('‚úÖ Arquivo baixado automaticamente');
                    showAlert('üíæ Arquivo baixado! Coloque em: Build/StreamingAssets/api-config.json', 'success');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Salvamento cancelado ou n√£o suportado:', error.message);
            }
        }


        // Update config display when custom server fields change
        document.addEventListener('DOMContentLoaded', function() {
            const customFields = ['customBaseUrl', 'customQuizEndpoint', 'customRankingEndpoint', 'customRegistrationEndpoint'];
            customFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', updateCurrentConfigDisplay);
                }
            });

            // Initialize config display on page load
            updateCurrentConfigDisplay();
        });

        // Schedule management functions
        function dateTimeToUnixTimestamp(dateStr, timeStr) {
            if (!dateStr || !timeStr) return 0;

            // Combinar data e hora em formato ISO
            const dateTimeStr = `${dateStr}T${timeStr}:00`;
            const date = new Date(dateTimeStr);

            // Retornar timestamp em segundos (n√£o milissegundos)
            return Math.floor(date.getTime() / 1000);
        }

        function unixTimestampToDateTime(timestamp) {
            if (!timestamp || timestamp === 0) return { date: '', time: '' };

            // Converter de segundos para milissegundos
            const date = new Date(timestamp * 1000);

            // Formatar data (YYYY-MM-DD)
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;

            // Formatar hora (HH:MM)
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;

            return { date: dateStr, time: timeStr };
        }

        function formatDateTimeBR(timestamp) {
            if (!timestamp || timestamp === 0) return 'N√£o configurado';

            const date = new Date(timestamp * 1000);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');

            return `${day}/${month}/${year} √†s ${hours}:${minutes}`;
        }

        function updateScheduleDisplay() {
            if (!quizData) return;

            const statusDiv = document.getElementById('scheduleStatus');
            const startTimestamp = quizData.startTimestamp || 0;
            const endTimestamp = quizData.endTimestamp || 0;

            if (startTimestamp === 0 && endTimestamp === 0) {
                statusDiv.innerHTML = '‚úÖ <strong style="color: #28a745;">Quiz sempre dispon√≠vel</strong>';
                return;
            }

            const now = Math.floor(Date.now() / 1000);
            let statusHtml = '<div style="line-height: 1.8;">';

            if (startTimestamp > 0) {
                statusHtml += `üìÖ <strong>In√≠cio:</strong> ${formatDateTimeBR(startTimestamp)}<br>`;
            }

            if (endTimestamp > 0) {
                statusHtml += `üìÖ <strong>T√©rmino:</strong> ${formatDateTimeBR(endTimestamp)}<br>`;
            }

            // Verificar status atual
            if (startTimestamp > 0 && now < startTimestamp) {
                const diffMinutes = Math.floor((startTimestamp - now) / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                let timeLeft = '';
                if (diffDays > 0) {
                    timeLeft = `${diffDays} dia(s)`;
                } else if (diffHours > 0) {
                    timeLeft = `${diffHours} hora(s)`;
                } else {
                    timeLeft = `${diffMinutes} minuto(s)`;
                }

                statusHtml += `<br>‚è≥ <strong style="color: #ffa726;">Quiz ainda n√£o come√ßou</strong> (faltam ${timeLeft})`;
            } else if (endTimestamp > 0 && now > endTimestamp) {
                statusHtml += `<br>üîí <strong style="color: #dc3545;">Quiz encerrado</strong>`;
            } else {
                statusHtml += `<br>‚úÖ <strong style="color: #28a745;">Quiz dispon√≠vel agora!</strong>`;
            }

            statusHtml += '</div>';
            statusDiv.innerHTML = statusHtml;

            // Preencher os campos de data/hora
            if (startTimestamp > 0) {
                const startDateTime = unixTimestampToDateTime(startTimestamp);
                document.getElementById('startDate').value = startDateTime.date;
                document.getElementById('startTime').value = startDateTime.time;
            }

            if (endTimestamp > 0) {
                const endDateTime = unixTimestampToDateTime(endTimestamp);
                document.getElementById('endDate').value = endDateTime.date;
                document.getElementById('endTime').value = endDateTime.time;
            }
        }

        function saveSchedule() {
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;

            // Converter para timestamps
            const startTimestamp = dateTimeToUnixTimestamp(startDate, startTime);
            const endTimestamp = dateTimeToUnixTimestamp(endDate, endTime);

            // Validar que fim √© depois do in√≠cio (se ambos configurados)
            if (startTimestamp > 0 && endTimestamp > 0 && endTimestamp <= startTimestamp) {
                showAlert('A data/hora de t√©rmino deve ser posterior √† de in√≠cio!', 'error');
                return;
            }

            // Atualizar quizData
            if (!quizData) {
                quizData = {
                    title: "Quiz ClickDescubra 2025",
                    startTimestamp: 0,
                    endTimestamp: 0,
                    groups: [],
                    questions: []
                };
            }

            quizData.startTimestamp = startTimestamp;
            quizData.endTimestamp = endTimestamp;

            // Salvar na API
            saveQuestions().then(() => {
                updateScheduleDisplay();
                showAlert('Agendamento salvo com sucesso!', 'success');
            });
        }

        function clearSchedule() {
            if (!confirm('Tem certeza que deseja remover o agendamento? O quiz ficar√° sempre dispon√≠vel.')) {
                return;
            }

            // Limpar campos
            document.getElementById('startDate').value = '';
            document.getElementById('startTime').value = '';
            document.getElementById('endDate').value = '';
            document.getElementById('endTime').value = '';

            // Atualizar quizData
            if (quizData) {
                quizData.startTimestamp = 0;
                quizData.endTimestamp = 0;
            }

            // Salvar na API
            saveQuestions().then(() => {
                updateScheduleDisplay();
                showAlert('Agendamento removido! Quiz agora est√° sempre dispon√≠vel.', 'success');
            });
        }

        // Load questions on page load
        document.addEventListener('DOMContentLoaded', function () {
            loadQuestions();
            setupImageUpload();
        });

        async function loadQuestions() {
            setStatus('loading', 'Carregando perguntas...');

            try {
                const response = await fetch(getQuizURL(), {
                    method: 'GET',
                    headers: getRequestHeaders()
                });

                if (!response.ok) {
                    // Mensagem espec√≠fica para erro 404
                    if (response.status === 404 && API_CONFIG.apiType === 'jsonbin') {
                        console.error(`‚ùå Bin n√£o encontrado: ${getQuizURL()}`);
                        throw new Error(`Bin n√£o encontrado (404)!\n\nO Bin ID n√£o existe no JSONBin.io.\nURL tentada: ${getQuizURL()}\n\nSolu√ß√µes:\n1. Verifique o Bin ID na aba Configura√ß√µes\n2. Crie um novo Bin em https://jsonbin.io\n3. Ou use o servidor customizado`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                quizData = await response.json();

                // Converter JSON antigo (questions) para novo formato (groups)
                if (quizData && !quizData.groups && quizData.questions) {
                    console.log('‚ö†Ô∏è JSON antigo detectado - convertendo para formato de grupos');
                    quizData.groups = [{
                        id: 'group1',
                        name: '',
                        completionMessage: 'Parab√©ns! Voc√™ completou este grupo!',
                        questions: quizData.questions
                    }];
                }

                // Garantir que groups existe
                if (!quizData.groups) {
                    quizData.groups = [];
                }

                // Garantir que campos de agendamento existem
                if (quizData.startTimestamp === undefined) {
                    quizData.startTimestamp = 0;
                }
                if (quizData.endTimestamp === undefined) {
                    quizData.endTimestamp = 0;
                }

                // Normalizar imagens
                if (quizData && quizData.groups) {
                    quizData.groups.forEach(group => {
                        if (group.questions) {
                            group.questions.forEach(normalizeLegacyImage);
                        }
                    });
                }

                // Migrar automaticamente imagens antigas para o novo sistema (JSONBin apenas)
                if (API_CONFIG.apiType === 'jsonbin') {
                    const migratedCount = migrateOldImagesToNewSystem();
                    if (migratedCount > 0) {
                        console.log(`üîÑ ${migratedCount} imagens migradas para o novo sistema (bins separados)`);
                        showAlert(`üîÑ ${migratedCount} imagem(ns) antiga(s) detectada(s)!\n\nForam migradas automaticamente para o novo sistema de bins separados.\n\n‚ö†Ô∏è IMPORTANTE: Clique em "Salvar Perguntas" para aplicar a migra√ß√£o!`, 'warning');
                    }

                    // Carregar imagens dos bins separados
                    await loadAllGroupImages();
                }

                const totalQuestions = quizData.groups.reduce((sum, g) => sum + (g.questions?.length || 0), 0);
                setStatus('success', `‚úÖ ${quizData.groups.length} grupos e ${totalQuestions} perguntas carregadas`);

                displayGroups();
                displayQuestions();
                updateStats();
                updateGroupSelector();
                updateScheduleDisplay();

            } catch (error) {
                console.error('Error loading questions:', error);

                // Detectar erro CORS
                if (error.message.includes('Failed to fetch') || error.toString().includes('NetworkError')) {
                    setStatus('error', '‚ùå Erro CORS - Configure o servidor!');
                    showAlert('‚ö†Ô∏è Erro de CORS detectado!\n\nO servidor precisa ter os headers:\n- Access-Control-Allow-Origin: *\n- Access-Control-Allow-Methods: GET, POST, OPTIONS\n- Access-Control-Allow-Headers: Content-Type\n\nOu volte para JSONBin.io na aba de Configura√ß√µes.', 'error');
                } else {
                    setStatus('error', '‚ùå Erro ao carregar perguntas');
                }
                showAlert('Erro ao carregar perguntas: ' + error.message, 'error');
            }
        }

        /**
         * Migra automaticamente imagens antigas (base64 inline) para o novo sistema (bins separados)
         * Gera imageId para imagens que ainda n√£o t√™m
         */
        function migrateOldImagesToNewSystem() {
            if (!quizData || !quizData.groups) return 0;

            let migratedCount = 0;

            quizData.groups.forEach(group => {
                if (!group.questions) return;

                group.questions.forEach(question => {
                    // Se tem base64 mas n√£o tem imageId, precisa migrar
                    if (question.imageBase64 && !question.imageId) {
                        // Gerar imageId √∫nico
                        question.imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                        // Garantir que todos os campos de imagem existem
                        if (!question.imageMimeType) {
                            question.imageMimeType = 'image/png';
                        }
                        if (!question.imageFilename) {
                            question.imageFilename = `question_${question.id || Date.now()}.png`;
                        }
                        if (!question.imageOriginalName) {
                            question.imageOriginalName = question.imageFilename;
                        }

                        migratedCount++;
                        const questionText = question.text || question.question || 'Quest√£o';
                        console.log(`‚úÖ Imagem migrada: ${questionText.substring(0, 30)}... ‚Üí ${question.imageId}`);
                    }
                });
            });

            return migratedCount;
        }

        /**
         * Carrega as imagens de todos os grupos dos bins separados e reconstr√≥i o base64 nas quest√µes
         * Isso permite que o manager exiba as imagens normalmente
         * Carrega tanto bins principais quanto bins extras
         */
        async function loadAllGroupImages() {
            if (!quizData || !quizData.groups) return;

            console.log('üñºÔ∏è Carregando imagens dos bins separados...');

            for (let groupIndex = 0; groupIndex < quizData.groups.length; groupIndex++) {
                const group = quizData.groups[groupIndex];

                // Verificar se alguma quest√£o tem imageId (novo sistema)
                const hasNewSystemImages = group.questions && group.questions.some(q => q.imageId && !q.imageBase64);

                if (!hasNewSystemImages) {
                    continue; // Grupo j√° tem imagens inline ou n√£o tem imagens
                }

                const binIdKey = `group${groupIndex + 1}ImagesBinId`;
                const binId = API_CONFIG.jsonbin[binIdKey];

                if (!binId) {
                    console.warn(`‚ö†Ô∏è Bin ID n√£o configurado para grupo ${groupIndex + 1}`);
                    continue;
                }

                const imagesMap = {};

                try {
                    // Carregar bin principal
                    const url = `${API_CONFIG.jsonbin.baseUrl}/${binId}/latest`;
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': API_CONFIG.jsonbin.apiKey,
                            'Accept': 'application/json',
                            'X-Bin-Meta': 'false'
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();

                        // Adicionar imagens do bin principal ao mapa
                        if (data.images) {
                            data.images.forEach(img => {
                                imagesMap[img.imageId] = img;
                            });
                        }

                        console.log(`‚úÖ Bin principal do grupo ${groupIndex + 1}: ${data.images?.length || 0} imagens`);
                    } else if (response.status === 404) {
                        console.log(`üì≠ Bin principal vazio para grupo ${groupIndex + 1} (404)`);
                    } else {
                        console.error(`‚ùå Erro ao carregar bin principal do grupo ${groupIndex + 1}: ${response.status}`);
                    }

                    // Carregar bins extras se existirem
                    if (quizData.extraImageBins && quizData.extraImageBins[groupIndex]) {
                        const extraBinIds = quizData.extraImageBins[groupIndex];
                        console.log(`üîÑ Carregando ${extraBinIds.length} bin(s) extra(s) do grupo ${groupIndex + 1}...`);

                        for (let i = 0; i < extraBinIds.length; i++) {
                            const extraBinId = extraBinIds[i];
                            if (!extraBinId) continue;

                            try {
                                const extraUrl = `${API_CONFIG.jsonbin.baseUrl}/${extraBinId}/latest`;
                                const extraResponse = await fetch(extraUrl, {
                                    method: 'GET',
                                    headers: {
                                        'X-Master-Key': API_CONFIG.jsonbin.apiKey,
                                        'Accept': 'application/json',
                                        'X-Bin-Meta': 'false'
                                    }
                                });

                                if (extraResponse.ok) {
                                    const extraData = await extraResponse.json();
                                    if (extraData.images) {
                                        extraData.images.forEach(img => {
                                            imagesMap[img.imageId] = img;
                                        });
                                    }
                                    console.log(`‚úÖ Bin extra ${i + 1} do grupo ${groupIndex + 1}: ${extraData.images?.length || 0} imagens`);
                                }
                            } catch (extraError) {
                                console.error(`‚ùå Erro ao carregar bin extra ${i + 1} do grupo ${groupIndex + 1}:`, extraError);
                            }
                        }
                    }

                    // Hidratar quest√µes com base64 de todos os bins (principal + extras)
                    if (group.questions) {
                        group.questions.forEach(question => {
                            if (question.imageId && imagesMap[question.imageId]) {
                                const imgData = imagesMap[question.imageId];
                                question.imageBase64 = imgData.base64;
                                question.imageMimeType = imgData.mimeType;
                                question.imageFilename = imgData.filename;
                                question.imageOriginalName = imgData.originalName;
                            }
                        });
                    }

                    const totalImages = Object.keys(imagesMap).length;
                    console.log(`‚úÖ Total de imagens do grupo ${groupIndex + 1}: ${totalImages}`);

                } catch (error) {
                    console.error(`‚ùå Erro ao carregar imagens do grupo ${groupIndex + 1}:`, error);
                }
            }

            console.log('‚úÖ Carregamento de imagens conclu√≠do');
        }

        /**
         * Salva as imagens de cada grupo em bins separados (1 MB cada)
         * Cada grupo tem seu pr√≥prio bin de imagens no JSONBin
         */
        /**
         * Cria um novo bin no JSONBin.io
         * @param {string} binName - Nome do bin
         * @param {object} initialData - Dados iniciais do bin
         * @returns {Promise<string>} - ID do bin criado
         */
        async function createNewBin(binName, initialData) {
            const url = `${API_CONFIG.jsonbin.baseUrl}`;

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Master-Key': API_CONFIG.jsonbin.apiKey,
                    'X-Bin-Name': binName,
                    'X-Bin-Private': 'true'
                },
                body: JSON.stringify(initialData)
            });

            if (!response.ok) {
                throw new Error(`Falha ao criar bin: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            console.log(`‚úÖ Bin criado: ${binName} (ID: ${result.metadata.id})`);
            return result.metadata.id;
        }

        /**
         * Divide imagens em chunks de no m√°ximo 900 KB (margem de seguran√ßa do limite de 1 MB)
         */
        function splitImagesIntoChunks(images, maxSizeBytes = 900 * 1024) {
            const chunks = [];
            let currentChunk = [];
            let currentSize = 0;

            for (const image of images) {
                const imageSize = JSON.stringify(image).length;

                // Se a imagem sozinha j√° excede o limite, adiciona em chunk separado
                if (imageSize > maxSizeBytes) {
                    console.warn(`‚ö†Ô∏è Imagem ${image.imageId} muito grande (${(imageSize/1024).toFixed(0)} KB)`);
                    if (currentChunk.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentSize = 0;
                    }
                    chunks.push([image]);
                    continue;
                }

                // Se adicionar esta imagem ultrapassar o limite, inicia novo chunk
                if (currentSize + imageSize > maxSizeBytes && currentChunk.length > 0) {
                    chunks.push(currentChunk);
                    currentChunk = [];
                    currentSize = 0;
                }

                currentChunk.push(image);
                currentSize += imageSize;
            }

            if (currentChunk.length > 0) {
                chunks.push(currentChunk);
            }

            return chunks;
        }

        async function saveGroupImages() {
            if (API_CONFIG.apiType !== 'jsonbin') {
                console.log('‚è≠Ô∏è Sistema de imagens separadas s√≥ funciona com JSONBin');
                return true;
            }

            console.log('üñºÔ∏è Salvando imagens em bins separados por grupo...');

            try {
                // Inicializar estrutura de bins extras se n√£o existir
                if (!quizData.extraImageBins) {
                    quizData.extraImageBins = {};
                }

                // Preparar dados de imagens por grupo
                for (let groupIndex = 0; groupIndex < quizData.groups.length; groupIndex++) {
                    const group = quizData.groups[groupIndex];
                    const imagesForGroup = [];

                    // Coletar todas as imagens do grupo
                    if (group.questions) {
                        group.questions.forEach(question => {
                            if (question.imageId && question.imageBase64) {
                                imagesForGroup.push({
                                    imageId: question.imageId,
                                    base64: question.imageBase64,
                                    mimeType: question.imageMimeType,
                                    filename: question.imageFilename,
                                    originalName: question.imageOriginalName
                                });
                            }
                        });
                    }

                    if (imagesForGroup.length === 0) {
                        console.log(`‚è≠Ô∏è Grupo ${groupIndex + 1}: sem imagens para salvar`);
                        continue;
                    }

                    // Dividir em chunks de 900 KB
                    const chunks = splitImagesIntoChunks(imagesForGroup);
                    console.log(`üì¶ Grupo ${groupIndex + 1}: ${imagesForGroup.length} imagens divididas em ${chunks.length} bin(s)`);

                    // Salvar primeiro chunk no bin principal
                    const binIdKey = `group${groupIndex + 1}ImagesBinId`;
                    const binId = API_CONFIG.jsonbin[binIdKey];

                    if (!binId) {
                        console.warn(`‚ö†Ô∏è Bin ID n√£o configurado para grupo ${groupIndex + 1}`);
                        continue;
                    }

                    // Salvar bin principal (primeiro chunk)
                    const mainPayload = { images: chunks[0] };
                    const mainSize = JSON.stringify(mainPayload).length;
                    console.log(`üì§ Salvando ${chunks[0].length} imagens no bin principal do grupo ${groupIndex + 1} (${(mainSize/1024).toFixed(0)} KB)`);

                    const mainResponse = await fetch(`${API_CONFIG.jsonbin.baseUrl}/${binId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Master-Key': API_CONFIG.jsonbin.apiKey,
                            'X-Bin-Meta': 'false'
                        },
                        body: JSON.stringify(mainPayload)
                    });

                    if (!mainResponse.ok) {
                        const errorMsg = `Erro ao salvar bin principal do grupo ${groupIndex + 1}: ${mainResponse.status}`;
                        console.error(errorMsg);
                        showAlert(errorMsg, 'error');
                        return false;
                    }

                    console.log(`‚úÖ Bin principal do grupo ${groupIndex + 1} salvo`);

                    // Salvar chunks extras em bins separados
                    if (chunks.length > 1) {
                        console.log(`üîÑ Criando ${chunks.length - 1} bin(s) extra(s) para grupo ${groupIndex + 1}...`);
                        showAlert(`‚ö†Ô∏è Grupo ${groupIndex + 1} excedeu 900 KB. Criando ${chunks.length - 1} bin(s) extra(s)...`, 'warning');

                        // Inicializar array de bins extras para este grupo
                        if (!quizData.extraImageBins[groupIndex]) {
                            quizData.extraImageBins[groupIndex] = [];
                        }

                        // Processar chunks extras (√≠ndice 1 em diante)
                        for (let chunkIndex = 1; chunkIndex < chunks.length; chunkIndex++) {
                            const chunk = chunks[chunkIndex];
                            const binName = `ExtraGroupImages${groupIndex}_${chunkIndex}`;

                            // Verificar se j√° existe um bin extra para este chunk
                            let extraBinId = quizData.extraImageBins[groupIndex][chunkIndex - 1];

                            if (!extraBinId) {
                                // Criar novo bin
                                console.log(`üÜï Criando novo bin: ${binName}`);
                                showLoadingOverlay(`Criando bin extra: ${binName}...`);
                                extraBinId = await createNewBin(binName, { images: chunk });
                                quizData.extraImageBins[groupIndex][chunkIndex - 1] = extraBinId;
                                console.log(`‚úÖ Bin ${binName} criado com ID: ${extraBinId}`);
                            } else {
                                // Atualizar bin existente
                                console.log(`üì§ Atualizando bin extra: ${binName} (${extraBinId})`);
                                const extraPayload = { images: chunk };
                                const extraResponse = await fetch(`${API_CONFIG.jsonbin.baseUrl}/${extraBinId}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-Master-Key': API_CONFIG.jsonbin.apiKey,
                                        'X-Bin-Meta': 'false'
                                    },
                                    body: JSON.stringify(extraPayload)
                                });

                                if (!extraResponse.ok) {
                                    console.error(`‚ùå Erro ao atualizar bin extra ${binName}`);
                                    return false;
                                }
                            }

                            const chunkSize = JSON.stringify({ images: chunk }).length;
                            console.log(`‚úÖ Bin extra ${binName} salvo: ${chunk.length} imagens (${(chunkSize/1024).toFixed(0)} KB)`);
                        }
                    }
                }

                console.log('‚úÖ Todas as imagens salvas nos bins separados');
                return true;

            } catch (error) {
                console.error('‚ùå Erro ao salvar imagens separadas:', error);
                showAlert('Erro ao salvar imagens: ' + error.message, 'error');
                return false;
            }
        }

        /**
         * Mostra o overlay de loading e desabilita intera√ß√µes
         */
        function showLoadingOverlay(message = 'Salvando...') {
            const overlay = document.getElementById('loadingOverlay');
            const messageEl = document.getElementById('loadingMessage');
            messageEl.textContent = message;
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * Esconde o overlay de loading e reabilita intera√ß√µes
         */
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        async function saveQuestions() {
            setStatus('loading', 'Salvando altera√ß√µes...');
            showLoadingOverlay('Salvando altera√ß√µes...');

            try {
                // Capturar estado ANTES de salvar
                const dataBeforeSave = JSON.parse(JSON.stringify(quizData));
                const groupCountBefore = dataBeforeSave.groups?.length || 0;
                const questionCountBefore = dataBeforeSave.groups?.reduce((sum, g) => sum + (g.questions?.length || 0), 0) || 0;

                console.log(`üìä ANTES DE SALVAR:
                    Grupos: ${groupCountBefore}
                    Perguntas: ${questionCountBefore}
                    Dados completos:`, dataBeforeSave);

                // Process images before saving
                processImagesForSaving();

                // NOVO SISTEMA: Salvar imagens em bins separados (JSONBin apenas)
                if (API_CONFIG.apiType === 'jsonbin') {
                    setStatus('loading', 'Salvando imagens em bins separados...');
                    showLoadingOverlay('Salvando imagens em bins separados...');
                    const imagesSaved = await saveGroupImages();

                    if (!imagesSaved) {
                        setStatus('error', '‚ùå Erro ao salvar imagens');
                        hideLoadingOverlay();
                        return;
                    }

                    showLoadingOverlay('Salvando dados do quiz...');
                }

                // Criar c√≥pia limpa dos dados SEM base64 (apenas imageId)
                const cleanQuizData = JSON.parse(JSON.stringify(quizData));

                if (API_CONFIG.apiType === 'jsonbin') {
                    // Remover base64 das quest√µes (manter apenas imageId)
                    cleanQuizData.groups.forEach(group => {
                        if (group.questions) {
                            group.questions.forEach(question => {
                                if (question.imageId) {
                                    // Tem imageId: remover base64 (est√° no bin separado)
                                    delete question.imageBase64;
                                    delete question.imageMimeType;
                                    delete question.imageFilename;
                                    delete question.imageOriginalName;
                                }
                                // Se n√£o tem imageId, manter dados legados para compatibilidade
                            });
                        }
                    });
                }

                // Determinar o m√©todo HTTP correto: POST para servidor personalizado, PUT para JSONBin
                const method = API_CONFIG.apiType === 'jsonbin' ? 'PUT' : 'POST';

                const url = getUpdateURL('quiz');
                const headers = getRequestHeaders(true);

                // Usar dados limpos (sem base64) para JSONBin, dados originais para servidor customizado
                const dataToSave = API_CONFIG.apiType === 'jsonbin' ? cleanQuizData : quizData;

                const payloadSize = JSON.stringify(dataToSave).length;
                const payloadMB = (payloadSize / 1024 / 1024).toFixed(2);

                console.log(`üì§ SALVANDO quiz via ${method} para: ${url}`);
                console.log(`üìã Headers:`, headers);
                console.log(`üì¶ Payload size: ${payloadSize} bytes (${payloadMB} MB)`);
                console.log(`üìù Payload completo (primeiros 500 chars):`, JSON.stringify(dataToSave).substring(0, 500));

                // Limite de seguran√ßa: 8 MB para deixar margem dos 10 MB do JSONBin Pro
                const maxSafeSizeMB = 8;
                const maxSafeSize = maxSafeSizeMB * 1024 * 1024;

                if (payloadSize > maxSafeSize) {
                    const errorMsg = `‚ùå ERRO: Payload muito grande (${payloadMB} MB)!\n\nLimite de seguran√ßa: ${maxSafeSizeMB} MB\nLimite do JSONBin Pro: 10 MB\n\nPor favor, remova algumas imagens ou use imagens menores.`;
                    console.error(errorMsg);
                    setStatus('error', `‚ùå Dados muito grandes: ${payloadMB} MB`);
                    showAlert(errorMsg, 'error');
                    hideLoadingOverlay();
                    return;
                }

                // Avisar se estiver pr√≥ximo do limite (> 7 MB)
                if (payloadSize > 7 * 1024 * 1024) {
                    console.warn(`‚ö†Ô∏è Aten√ß√£o: Payload grande (${payloadMB} MB). Pr√≥ximo do limite de ${maxSafeSizeMB} MB!`);
                    showAlert(`‚ö†Ô∏è Aten√ß√£o: Dados grandes (${payloadMB} MB). Voc√™ est√° pr√≥ximo do limite de ${maxSafeSizeMB} MB.`, 'warning');
                }

                const response = await fetch(url, {
                    method: method,
                    headers: headers,
                    body: JSON.stringify(dataToSave)
                });

                console.log(`üì° Status da resposta: ${response.status} ${response.statusText}`);
                console.log(`üì° Headers da resposta:`, Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Erro na resposta:', response.status, errorText);

                    // Detectar erro S3
                    if (errorText.includes('<?xml') && errorText.includes('<Error>')) {
                        console.error('ü™£ Erro do S3 detectado! O bucket pode estar configurado apenas para leitura.');
                        throw new Error(`Erro S3 (${response.status}): Bucket sem permiss√£o de escrita.\n\nO servidor S3 n√£o permite PUT. Configure permiss√µes ou use JSONBin.io.`);
                    }

                    // Mensagem espec√≠fica para erro 404
                    if (response.status === 404 && API_CONFIG.apiType === 'jsonbin') {
                        console.error(`‚ùå Bin n√£o encontrado: ${getUpdateURL('quiz')}`);
                        throw new Error(`Bin n√£o encontrado (404)!\n\nO Bin ID n√£o existe no JSONBin.io.\nURL tentada: ${getUpdateURL('quiz')}\n\nSolu√ß√µes:\n1. Verifique o Bin ID na aba Configura√ß√µes\n2. Crie um novo Bin em https://jsonbin.io\n3. Ou use o servidor customizado`);
                    }

                    throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
                }

                const result = await response.text();
                console.log('‚úÖ Resposta do servidor:', result);

                // VERIFICAR SE DADOS FORAM SALVOS REALMENTE
                console.log('üîç Verificando se dados foram persistidos...');
                setTimeout(async () => {
                    try {
                        const verifyResponse = await fetch(getQuizURL(), {
                            method: 'GET',
                            headers: getRequestHeaders()
                        });

                        if (verifyResponse.ok) {
                            const savedData = await verifyResponse.json();
                            const groupCountAfter = savedData.groups?.length || 0;
                            const questionCountAfter = savedData.groups?.reduce((sum, g) => sum + (g.questions?.length || 0), 0) || 0;

                            console.log(`üìä DEPOIS DE SALVAR (verifica√ß√£o):
                                Grupos: ${groupCountAfter} (era ${groupCountBefore})
                                Perguntas: ${questionCountAfter} (era ${questionCountBefore})
                                Dados completos:`, savedData);

                            // Comparar JSON stringificado para detectar mudan√ßas reais
                            const dataBeforeString = JSON.stringify(dataBeforeSave);
                            const dataAfterString = JSON.stringify(savedData);

                            if (dataBeforeString !== dataAfterString) {
                                console.log(`‚úÖ DADOS VERIFICADOS: Altera√ß√µes confirmadas e persistidas!`);
                            } else {
                                console.warn(`‚ö†Ô∏è Dados parecem id√™nticos - pode ser que n√£o tenha havido mudan√ßas ou servidor n√£o salvou.`);
                            }
                        }
                    } catch (verifyError) {
                        console.warn('N√£o foi poss√≠vel verificar salvamento:', verifyError);
                    }
                }, 1000);

                setStatus('success', '‚úÖ Altera√ß√µes salvas com sucesso');
                showAlert('Perguntas salvas com sucesso!', 'success');
                hideLoadingOverlay();

            } catch (error) {
                console.error('Error saving questions:', error);
                setStatus('error', '‚ùå Erro ao salvar');
                showAlert('Erro ao salvar: ' + error.message, 'error');
                hideLoadingOverlay();
            }
        }

        function processImagesForSaving() {
            if (!quizData || !quizData.groups) return;

            quizData.groups.forEach(group => {
                if (!group.questions) return;

                group.questions.forEach(question => {
                    normalizeLegacyImage(question);

                    if (question.imageBase64) {
                        question.imageMimeType = question.imageMimeType || 'image/png';
                        if (!question.imageFilename) {
                            const extension = (question.imageOriginalName || 'imagem.png').split('.').pop();
                            question.imageFilename = `question_${question.id || Date.now()}.${extension || 'png'}`;
                        }
                    }
                });
            });

            // Manter questions para compatibilidade (todas as quest√µes de todos os grupos)
            quizData.questions = [];
            quizData.groups.forEach(group => {
                if (group.questions) {
                    quizData.questions = quizData.questions.concat(group.questions);
                }
            });
        }

        function downloadAllImages() {
            if (!quizData || !quizData.questions) return;

            const imagesWithData = quizData.questions.filter(q => q.imageBase64);

            if (imagesWithData.length === 0) {
                showAlert('Nenhuma imagem encontrada para download.', 'info');
                return;
            }

            let downloadCount = 0;
            imagesWithData.forEach((question, index) => {
                setTimeout(() => {
                    const dataUrl = buildDataUrl(question.imageBase64, question.imageMimeType || 'image/png');
                    const filename = question.imageFilename || `question_${question.id || index}.png`;

                    const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    downloadCount++;

                    if (downloadCount === imagesWithData.length) {
                        showAlert(`${downloadCount} imagens exportadas.`, 'success');
                    }
                }, index * 200);
            });
        }

        // Group management functions
        function addGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            const groupIntroMessage = document.getElementById('groupIntroMessage').value.trim();
            const groupMessage = document.getElementById('groupMessage').value.trim();

            if (!groupMessage) {
                showAlert('Por favor, digite a mensagem de conclus√£o.', 'error');
                return;
            }

            if (!quizData) {
                quizData = {
                    title: "Quiz ClickDescubra 2025",
                    groups: [],
                    questions: []
                };
            }

            if (!quizData.groups) {
                quizData.groups = [];
            }

            if (quizData.groups.length >= 6) {
                showAlert('M√°ximo de 6 grupos atingido!', 'error');
                return;
            }

            const newGroup = {
                id: 'group' + (Date.now()),
                name: groupName || '', // Vazio = usa "Grupo X"
                introductionMessage: groupIntroMessage || '',
                completionMessage: groupMessage,
                questions: []
            };

            quizData.groups.push(newGroup);

            clearGroupForm();
            resetToAddGroupMode();

            saveQuestions().then(() => {
                displayGroups();
                updateStats();
                updateGroupSelector();
            });

            showAlert('Grupo adicionado com sucesso!', 'success');
        }

        function editGroup(groupId) {
            const group = quizData.groups.find(g => g.id === groupId);
            if (!group) {
                showAlert('Grupo n√£o encontrado!', 'error');
                return;
            }

            editingGroupId = groupId;
            document.getElementById('groupFormTitle').textContent = '‚úèÔ∏è Editar Grupo';

            document.getElementById('groupName').value = group.name || '';
            document.getElementById('groupIntroMessage').value = group.introductionMessage || '';
            document.getElementById('groupMessage').value = group.completionMessage || '';

            document.getElementById('groupFormActions').innerHTML = `
                <button class="btn btn-success" onclick="updateGroup()">
                    üíæ Salvar Altera√ß√µes
                </button>
                <button class="btn btn-danger" onclick="cancelGroupEdit()">
                    ‚ùå Cancelar
                </button>
            `;

            document.getElementById('groupFormTitle').scrollIntoView({ behavior: 'smooth' });
        }

        function updateGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            const groupIntroMessage = document.getElementById('groupIntroMessage').value.trim();
            const groupMessage = document.getElementById('groupMessage').value.trim();

            if (!groupMessage) {
                showAlert('Por favor, digite a mensagem de conclus√£o.', 'error');
                return;
            }

            const groupIndex = quizData.groups.findIndex(g => g.id === editingGroupId);
            if (groupIndex === -1) {
                showAlert('Grupo n√£o encontrado!', 'error');
                return;
            }

            quizData.groups[groupIndex].name = groupName || '';
            quizData.groups[groupIndex].introductionMessage = groupIntroMessage || '';
            quizData.groups[groupIndex].completionMessage = groupMessage;

            clearGroupForm();
            resetToAddGroupMode();

            saveQuestions().then(() => {
                displayGroups();
                updateStats();
                updateGroupSelector();
            });

            showAlert('Grupo atualizado com sucesso!', 'success');
        }

        function deleteGroup(groupId) {
            const group = quizData.groups.find(g => g.id === groupId);
            if (!group) return;

            const questionCount = group.questions?.length || 0;
            if (questionCount > 0) {
                if (!confirm(`Este grupo tem ${questionCount} pergunta(s). Tem certeza que deseja excluir?`)) {
                    return;
                }
            } else {
                if (!confirm('Tem certeza que deseja excluir este grupo?')) {
                    return;
                }
            }

            quizData.groups = quizData.groups.filter(g => g.id !== groupId);

            saveQuestions().then(() => {
                displayGroups();
                updateStats();
                updateGroupSelector();
            });

            showAlert('Grupo exclu√≠do com sucesso!', 'success');
        }

        function cancelGroupEdit() {
            clearGroupForm();
            resetToAddGroupMode();
        }

        function clearGroupForm() {
            document.getElementById('groupName').value = '';
            document.getElementById('groupIntroMessage').value = '';
            document.getElementById('groupMessage').value = '';
        }

        function resetToAddGroupMode() {
            editingGroupId = null;
            document.getElementById('groupFormTitle').textContent = '‚ûï Adicionar Novo Grupo';
            document.getElementById('groupFormActions').innerHTML = `
                <button class="btn btn-primary" onclick="addGroup()">
                    ‚ûï Adicionar Grupo
                </button>
            `;
        }

        function displayGroups() {
            const container = document.getElementById('groupsList');

            if (!quizData || !quizData.groups || quizData.groups.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Nenhum grupo criado. Adicione o primeiro grupo!</p>';
                return;
            }

            container.innerHTML = quizData.groups.map((group, index) => {
                const displayName = group.name || `Grupo ${index + 1}`;
                const questionCount = group.questions?.length || 0;

                return `
                    <div class="group-card">
                        <div class="group-header">
                            <div class="group-title">${displayName}</div>
                            <div class="group-actions">
                                <button class="btn btn-primary btn-small" onclick="editGroup('${group.id}')">
                                    ‚úèÔ∏è Editar
                                </button>
                                <button class="btn btn-danger btn-small" onclick="deleteGroup('${group.id}')">
                                    üóëÔ∏è Excluir
                                </button>
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>Mensagem:</strong> ${group.completionMessage || 'Sem mensagem'}
                        </div>
                        <div style="color: #666;">
                            <strong>${questionCount}</strong> pergunta(s) neste grupo
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateGroupSelector() {
            const select = document.getElementById('questionGroup');
            if (!select) return;

            const currentValue = select.value;

            if (!quizData || !quizData.groups || quizData.groups.length === 0) {
                select.innerHTML = '<option value="">Nenhum grupo dispon√≠vel - crie um grupo primeiro</option>';
                return;
            }

            select.innerHTML = '<option value="">Selecione um grupo...</option>' +
                quizData.groups.map((group, index) => {
                    const displayName = group.name || `Grupo ${index + 1}`;
                    return `<option value="${group.id}">${displayName}</option>`;
                }).join('');

            // Restaurar valor selecionado se poss√≠vel
            if (currentValue) {
                select.value = currentValue;
            }

            // Atualizar tamb√©m o filtro de grupos
            updateFilterGroupSelector();
        }

        function updateFilterGroupSelector() {
            const filterSelect = document.getElementById('filterGroup');
            if (!filterSelect) return;

            const currentValue = currentFilterGroupId || filterSelect.value;

            if (!quizData || !quizData.groups || quizData.groups.length === 0) {
                filterSelect.innerHTML = '<option value="">Nenhum grupo dispon√≠vel</option>';
                return;
            }

            filterSelect.innerHTML = '<option value="">Todos os Grupos</option>' +
                quizData.groups.map((group, index) => {
                    const displayName = group.name || `Grupo ${index + 1}`;
                    return `<option value="${group.id}">${displayName}</option>`;
                }).join('');

            if (currentValue) {
                filterSelect.value = currentValue;
            }
        }

        function filterQuestionsByGroup() {
            const filterSelect = document.getElementById('filterGroup');
            currentFilterGroupId = filterSelect.value;
            displayQuestions();
        }

        function moveQuestionToGroup(questionId) {
            // Encontrar a quest√£o atual e seu grupo
            let currentGroup = null;
            let question = null;

            for (const group of quizData.groups) {
                if (group.questions) {
                    const found = group.questions.find(q => q.id === questionId);
                    if (found) {
                        question = found;
                        currentGroup = group;
                        break;
                    }
                }
            }

            if (!question || !currentGroup) {
                showAlert('Quest√£o n√£o encontrada!', 'error');
                return;
            }

            // Criar op√ß√µes de grupos (exceto o atual)
            const groupOptions = quizData.groups
                .filter(g => g.id !== currentGroup.id)
                .map((group, index) => {
                    const displayName = group.name || `Grupo ${quizData.groups.indexOf(group) + 1}`;
                    return `<option value="${group.id}">${displayName}</option>`;
                })
                .join('');

            if (!groupOptions) {
                showAlert('N√£o h√° outros grupos dispon√≠veis!', 'error');
                return;
            }

            // Criar um modal simples para selecionar o grupo destino
            const currentGroupName = currentGroup.name || `Grupo ${quizData.groups.indexOf(currentGroup) + 1}`;
            const targetGroupId = prompt(`Mover quest√£o do grupo "${currentGroupName}" para qual grupo?\n\nDigite o n√∫mero do grupo (1-${quizData.groups.length}):`);

            if (!targetGroupId) return;

            const targetIndex = parseInt(targetGroupId) - 1;
            if (isNaN(targetIndex) || targetIndex < 0 || targetIndex >= quizData.groups.length) {
                showAlert('N√∫mero de grupo inv√°lido!', 'error');
                return;
            }

            const targetGroup = quizData.groups[targetIndex];
            if (targetGroup.id === currentGroup.id) {
                showAlert('A quest√£o j√° est√° neste grupo!', 'error');
                return;
            }

            // Mover a quest√£o
            const questionIndex = currentGroup.questions.findIndex(q => q.id === questionId);
            currentGroup.questions.splice(questionIndex, 1);

            if (!targetGroup.questions) {
                targetGroup.questions = [];
            }
            targetGroup.questions.push(question);

            // Salvar e atualizar
            saveQuestions().then(() => {
                displayGroups();
                displayQuestions();
                updateStats();

                const targetGroupName = targetGroup.name || `Grupo ${targetIndex + 1}`;
                showAlert(`Quest√£o movida para "${targetGroupName}" com sucesso!`, 'success');
            });
        }

        function addQuestion() {
            const questionText = document.getElementById('questionText').value.trim();
            const option0 = document.getElementById('option0').value.trim();
            const option1 = document.getElementById('option1').value.trim();
            const option2 = document.getElementById('option2').value.trim();
            const option3 = document.getElementById('option3').value.trim();
            const selectedGroupId = document.getElementById('questionGroup').value;
            const category = document.getElementById('category').value.trim();
            const timeSeconds = parseInt(document.getElementById('timeSeconds').value);
            const correctOption = document.querySelector('input[name="correctOption"]:checked');

            // Validation
            if (!questionText) {
                showAlert('Por favor, digite a pergunta.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!option0 || !option1 || !option2 || !option3) {
                showAlert('Por favor, preencha todas as 4 op√ß√µes.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!correctOption) {
                showAlert('Por favor, selecione a resposta correta.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!selectedGroupId) {
                showAlert('Por favor, selecione um grupo.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!category) {
                showAlert('Por favor, digite a categoria.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!quizData) {
                quizData = {
                    title: "Quiz ClickDescubra 2025",
                    groups: [],
                    questions: []
                };
            }

            if (!quizData.groups) {
                quizData.groups = [];
            }

            // Encontrar o grupo selecionado
            const group = quizData.groups.find(g => g.id === selectedGroupId);
            if (!group) {
                showAlert('Grupo n√£o encontrado!', 'error');
                return;
            }

            if (!group.questions) {
                group.questions = [];
            }

            // Create new question
            const newQuestion = {
                id: 'q' + (Date.now()),
                question: questionText,
                options: [option0, option1, option2, option3],
                correctIndex: parseInt(correctOption.value),
                timeSeconds: timeSeconds,
                category: category
            };

            // Add image if provided (novo sistema: s√≥ imageId, base64 vai para bin separado)
            if (currentImageData && currentImageData.base64) {
                newQuestion.imageId = currentImageData.imageId;
                // Manter dados legados para compatibilidade tempor√°ria
                newQuestion.imageBase64 = currentImageData.base64;
                newQuestion.imageMimeType = currentImageData.mimeType;
                newQuestion.imageFilename = currentImageData.filename;
                newQuestion.imageOriginalName = currentImageData.originalName;
            }

            group.questions.push(newQuestion);

            // Clear form and reset to add mode
            clearForm();
            resetToAddMode();

            // Save and refresh
            saveQuestions().then(() => {
                displayGroups();
                displayQuestions();
                updateStats();
            });

            showAlert('Pergunta adicionada com sucesso!', 'success');
        }

        function editQuestion(questionId) {
            // Procurar a pergunta em todos os grupos
            let question = null;
            let groupId = null;

            for (const group of quizData.groups) {
                if (group.questions) {
                    const found = group.questions.find(q => q.id === questionId);
                    if (found) {
                        question = found;
                        groupId = group.id;
                        break;
                    }
                }
            }

            if (!question) {
                showAlert('Pergunta n√£o encontrada!', 'error');
                return;
            }

            // Set form to edit mode
            editingQuestionId = questionId;
            document.getElementById('formTitle').textContent = '‚úèÔ∏è Editar Pergunta';

            // Fill form with question data
            document.getElementById('questionText').value = question.question;
            document.getElementById('option0').value = question.options[0];
            document.getElementById('option1').value = question.options[1];
            document.getElementById('option2').value = question.options[2];
            document.getElementById('option3').value = question.options[3];
            document.getElementById('questionGroup').value = groupId;
            document.getElementById('category').value = question.category;
            document.getElementById('timeSeconds').value = question.timeSeconds;

            // Set correct option
            document.getElementById(`correct${question.correctIndex}`).checked = true;

            // Load image if exists
            normalizeLegacyImage(question);
            imageRemoved = false;

            if (question.imageBase64) {
                const mimeType = question.imageMimeType || 'image/png';
                const dataUrl = buildDataUrl(question.imageBase64, mimeType);
                const fallbackName = question.imageOriginalName || question.imageFilename || `${question.id || 'imagem'}.png`;
                const filename = question.imageFilename || generateImageFilename(fallbackName);

                currentImageData = {
                    filename: filename,
                    base64: question.imageBase64,
                    dataUrl: dataUrl,
                    mimeType: mimeType,
                    originalName: fallbackName
                };

                showImagePreview(dataUrl);
            } else if (question.imageFilename) {
                // Only has filename reference - show placeholder
                const container = document.getElementById('imagePreviewContainer');
                container.innerHTML = `
                    <div style="padding: 20px; background: #f0f0f0; border-radius: 8px; text-align: center;">
                        <p style="margin: 0; color: #666;">üñºÔ∏è Imagem vinculada: <strong>${question.imageFilename}</strong></p>
                        <small style="color: #999;">Para alterar, fa√ßa upload de uma nova imagem</small>
                        <br><br>
                        <input type="file" id="questionImage" accept="image/*" style="display: none;">
                        <button type="button" class="image-upload-btn" onclick="document.getElementById('questionImage').click()">
                            üîÑ Trocar Imagem
                        </button>
                        <button type="button" class="image-remove-btn" onclick="removeImage()">
                            üóëÔ∏è Remover
                        </button>
                    </div>
                `;
                // Reattach event listener to the new input
                document.getElementById('questionImage').addEventListener('change', handleImageUpload);
                currentImageData = null;
            } else {
                removeImage();
                imageRemoved = false;
            }

            // Update form buttons
            document.getElementById('formActions').innerHTML = `
                <button class="btn btn-success" onclick="updateQuestion()">
                    üíæ Salvar Altera√ß√µes
                </button>
                <button class="btn btn-danger" onclick="cancelEdit()">
                    ‚ùå Cancelar
                </button>
            `;

            // Scroll to form
            document.getElementById('formTitle').scrollIntoView({ behavior: 'smooth' });
        }

        function updateQuestion() {
            const questionText = document.getElementById('questionText').value.trim();
            const option0 = document.getElementById('option0').value.trim();
            const option1 = document.getElementById('option1').value.trim();
            const option2 = document.getElementById('option2').value.trim();
            const option3 = document.getElementById('option3').value.trim();
            const selectedGroupId = document.getElementById('questionGroup').value;
            const category = document.getElementById('category').value.trim();
            const timeSeconds = parseInt(document.getElementById('timeSeconds').value);
            const correctOption = document.querySelector('input[name="correctOption"]:checked');

            // Validation
            if (!questionText) {
                showAlert('Por favor, digite a pergunta.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!option0 || !option1 || !option2 || !option3) {
                showAlert('Por favor, preencha todas as 4 op√ß√µes.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!correctOption) {
                showAlert('Por favor, selecione a resposta correta.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!selectedGroupId) {
                showAlert('Por favor, selecione um grupo.', 'error', 'questionFormAlertContainer');
                return;
            }

            if (!category) {
                showAlert('Por favor, digite a categoria.', 'error', 'questionFormAlertContainer');
                return;
            }

            // Find the question in all groups
            let foundGroup = null;
            let questionIndex = -1;

            for (const group of quizData.groups) {
                if (group.questions) {
                    questionIndex = group.questions.findIndex(q => q.id === editingQuestionId);
                    if (questionIndex !== -1) {
                        foundGroup = group;
                        break;
                    }
                }
            }

            if (!foundGroup || questionIndex === -1) {
                showAlert('Pergunta n√£o encontrada!', 'error');
                return;
            }

            const updatedQuestion = {
                id: editingQuestionId,
                question: questionText,
                options: [option0, option1, option2, option3],
                correctIndex: parseInt(correctOption.value),
                timeSeconds: timeSeconds,
                category: category
            };

            // Add image if provided (novo sistema: imageId + dados legados para compatibilidade)
            if (currentImageData && currentImageData.base64) {
                updatedQuestion.imageId = currentImageData.imageId;
                // Manter dados legados para compatibilidade tempor√°ria
                updatedQuestion.imageBase64 = currentImageData.base64;
                updatedQuestion.imageMimeType = currentImageData.mimeType;
                updatedQuestion.imageFilename = currentImageData.filename;
                updatedQuestion.imageOriginalName = currentImageData.originalName;
            } else if (!imageRemoved) {
                const previous = foundGroup.questions[questionIndex];
                if (previous.imageId) {
                    // Novo sistema: manter imageId
                    updatedQuestion.imageId = previous.imageId;
                }
                if (previous.imageBase64) {
                    updatedQuestion.imageBase64 = previous.imageBase64;
                    updatedQuestion.imageMimeType = previous.imageMimeType;
                    updatedQuestion.imageFilename = previous.imageFilename;
                    updatedQuestion.imageOriginalName = previous.imageOriginalName;
                } else if (previous.imageFilename) {
                    updatedQuestion.imageFilename = previous.imageFilename;
                    updatedQuestion.imageOriginalName = previous.imageOriginalName;
                }
            } else {
                // Imagem removida: limpar tudo
                updatedQuestion.imageId = null;
                updatedQuestion.imageBase64 = null;
                updatedQuestion.imageMimeType = null;
                updatedQuestion.imageFilename = null;
                updatedQuestion.imageOriginalName = null;
            }

            // Se mudou de grupo, remover do grupo antigo e adicionar no novo
            if (foundGroup.id !== selectedGroupId) {
                foundGroup.questions.splice(questionIndex, 1);
                const newGroup = quizData.groups.find(g => g.id === selectedGroupId);
                if (newGroup) {
                    if (!newGroup.questions) newGroup.questions = [];
                    newGroup.questions.push(updatedQuestion);
                }
            } else {
                foundGroup.questions[questionIndex] = updatedQuestion;
            }

            // Clear form and reset to add mode
            clearForm();
            resetToAddMode();

            // Save and refresh
            saveQuestions().then(() => {
                displayGroups();
                displayQuestions();
                updateStats();
            });

            showAlert('Pergunta atualizada com sucesso!', 'success');
        }

        function cancelEdit() {
            clearForm();
            resetToAddMode();
        }

        function clearForm() {
            document.getElementById('questionText').value = '';
            document.getElementById('option0').value = '';
            document.getElementById('option1').value = '';
            document.getElementById('option2').value = '';
            document.getElementById('option3').value = '';
            document.getElementById('category').value = '';
            document.getElementById('timeSeconds').value = '150';

            // Clear radio buttons
            const checkedRadio = document.querySelector('input[name="correctOption"]:checked');
            if (checkedRadio) {
                checkedRadio.checked = false;
            }

            // Clear image
            removeImage();
            imageRemoved = false;
        }

        function resetToAddMode() {
            editingQuestionId = null;
            document.getElementById('formTitle').textContent = '‚ûï Adicionar Nova Pergunta';
            document.getElementById('formActions').innerHTML = `
                <button class="btn btn-primary" onclick="addQuestion()">
                    ‚ûï Adicionar Pergunta
                </button>
            `;
        }

        function deleteQuestion(questionId) {
            if (!confirm('Tem certeza que deseja excluir esta pergunta?')) {
                return;
            }

            if (quizData && quizData.groups) {
                // Procurar e remover a pergunta do grupo
                for (const group of quizData.groups) {
                    if (group.questions) {
                        const index = group.questions.findIndex(q => q.id === questionId);
                        if (index !== -1) {
                            group.questions.splice(index, 1);
                            break;
                        }
                    }
                }

                saveQuestions().then(() => {
                    displayGroups();
                    displayQuestions();
                    updateStats();
                });

                showAlert('Pergunta exclu√≠da com sucesso!', 'success');
            }
        }

        function displayQuestions() {
            const container = document.getElementById('questionsList');

            if (!quizData || !quizData.groups || quizData.groups.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Nenhuma pergunta encontrada.</p>';
                return;
            }

            // Coletar todas as perguntas de todos os grupos
            const allQuestionsWithGroup = [];
            quizData.groups.forEach((group, groupIndex) => {
                const groupName = group.name || `Grupo ${groupIndex + 1}`;
                if (group.questions) {
                    group.questions.forEach(question => {
                        allQuestionsWithGroup.push({
                            question,
                            groupName,
                            groupId: group.id
                        });
                    });
                }
            });

            // Aplicar filtro se houver
            let filteredQuestions = allQuestionsWithGroup;
            if (currentFilterGroupId) {
                filteredQuestions = allQuestionsWithGroup.filter(item => item.groupId === currentFilterGroupId);
            }

            if (filteredQuestions.length === 0) {
                const message = currentFilterGroupId
                    ? 'Nenhuma pergunta encontrada neste grupo.'
                    : 'Nenhuma pergunta encontrada.';
                container.innerHTML = `<p style="text-align: center; color: #666; padding: 40px;">${message}</p>`;
                return;
            }

            container.innerHTML = filteredQuestions.map(({ question, groupName }) => `
                <div class="question-card">
                    <div class="question-header">
                        <div class="question-title">${question.question}</div>
                    </div>
                    <div class="question-meta">
                        <strong>Grupo:</strong> ${groupName} |
                        <strong>Categoria:</strong> ${question.category} |
                        <strong>Tempo:</strong> ${question.timeSeconds}s |
                        <strong>ID:</strong> ${question.id}
                    </div>
                    ${question.imageBase64 ? `
                        <div style="margin: 10px 0; text-align: center;">
                            <img src="${buildDataUrl(question.imageBase64, question.imageMimeType || 'image/png')}" alt="Imagem da pergunta" class="question-image">
                            <p style="font-size: 12px; color: #666; margin: 5px 0;">${question.imageOriginalName || question.imageFilename || 'imagem.png'}</p>
                        </div>
                    ` : question.imageFilename ? `
                        <div class="no-image-placeholder">
                            üìÅ Imagem externa: ${question.imageFilename}
                        </div>
                    ` : `
                        <div class="no-image-placeholder">
                            üì∑ Sem imagem
                        </div>
                    `}
                    <div class="question-options">
                        ${question.options.map((option, index) => `
                            <div class="option ${index === question.correctIndex ? 'correct' : 'incorrect'}">
                                ${index === question.correctIndex ? '‚úì' : '‚óã'} ${option}
                            </div>
                        `).join('')}
                    </div>
                    <div class="question-actions">
                        <button class="btn btn-primary btn-small" onclick="editQuestion('${question.id}')">
                            ‚úèÔ∏è Editar
                        </button>
                        <button class="btn btn-warning btn-small" onclick="moveQuestionToGroup('${question.id}')">
                            üì¶ Mover
                        </button>
                        <button class="btn btn-danger btn-small" onclick="deleteQuestion('${question.id}')">
                            üóëÔ∏è Excluir
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function updateStats() {
            if (!quizData || !quizData.groups) {
                document.getElementById('totalGroups').textContent = '0';
                document.getElementById('totalQuestions').textContent = '0';
                document.getElementById('categoriesCount').textContent = '0';
                document.getElementById('avgTime').textContent = '0s';
                return;
            }

            const totalGroups = quizData.groups.length;

            // Coletar todas as perguntas de todos os grupos
            const allQuestions = [];
            quizData.groups.forEach(group => {
                if (group.questions) {
                    allQuestions.push(...group.questions);
                }
            });

            const totalQuestions = allQuestions.length;
            const categories = new Set(allQuestions.map(q => q.category)).size;
            const avgTime = allQuestions.length > 0 ?
                Math.round(allQuestions.reduce((sum, q) => sum + q.timeSeconds, 0) / allQuestions.length) : 0;

            document.getElementById('totalGroups').textContent = totalGroups;
            document.getElementById('totalQuestions').textContent = totalQuestions;
            document.getElementById('categoriesCount').textContent = categories;
            document.getElementById('avgTime').textContent = avgTime + 's';
        }

        /**
         * Atualiza as barras de progresso de uso de espa√ßo por grupo (Config tab)
         */
        function updateGroupStorageStats() {
            const container = document.getElementById('groupStorageStats');

            if (!quizData || !quizData.groups || API_CONFIG.apiType !== 'jsonbin') {
                container.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">Carregue um quiz JSONBin para ver o uso de espa√ßo</div>';
                return;
            }

            let html = '';
            const limitBytes = 1024 * 1024; // 1 MB

            quizData.groups.slice(0, 6).forEach((group, index) => {
                // Coletar imagens do grupo
                const groupImages = [];
                if (group.questions) {
                    group.questions.forEach(q => {
                        if (q.imageId && q.imageBase64) {
                            groupImages.push({
                                imageId: q.imageId,
                                base64: q.imageBase64,
                                mimeType: q.imageMimeType,
                                filename: q.imageFilename,
                                originalName: q.imageOriginalName
                            });
                        }
                    });
                }

                // Dividir em chunks para ver quantos bins ser√£o usados
                const chunks = splitImagesIntoChunks(groupImages);
                const totalBins = chunks.length || 0;

                // Calcular tamanho do maior bin
                let maxChunkSize = 0;
                chunks.forEach(chunk => {
                    const chunkSize = JSON.stringify({ images: chunk }).length;
                    if (chunkSize > maxChunkSize) {
                        maxChunkSize = chunkSize;
                    }
                });

                const percentage = Math.min(100, (maxChunkSize / limitBytes) * 100);
                const largestBinKB = (maxChunkSize / 1024).toFixed(0);

                // Determinar classe de cor baseado no maior bin
                let barClass = 'low';
                if (percentage >= 80) {
                    barClass = 'high';
                } else if (percentage >= 50) {
                    barClass = 'medium';
                }

                // Nome do grupo
                const groupName = group.name || `Grupo ${index + 1}`;
                const imageCount = groupImages.length;
                const binsInfo = totalBins > 1 ? ` ‚Ä¢ ${totalBins} bins` : '';

                html += `
                    <div class="storage-item">
                        <div class="storage-header">
                            <span class="storage-group-name">${groupName}</span>
                            <span class="storage-size-info">${imageCount} ${imageCount === 1 ? 'imagem' : 'imagens'}${binsInfo} ‚Ä¢ Maior bin: ${largestBinKB} KB / 1024 KB</span>
                        </div>
                        <div class="storage-bar-container">
                            <div class="storage-bar ${barClass}" style="width: ${percentage}%">
                                ${percentage > 10 ? percentage.toFixed(0) + '%' : ''}
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html || '<div style="color: #999; text-align: center; padding: 20px;">Nenhum grupo com imagens</div>';
        }

        function setStatus(type, message) {
            const icon = document.getElementById('statusIcon');
            const text = document.getElementById('statusText');

            icon.className = `status-icon ${type}`;
            text.textContent = message;
        }

        function showAlert(message, type, containerTargetId = 'alertContainer') {
            const container = document.getElementById(containerTargetId);
            if (!container) {
                console.error(`Container ${containerTargetId} n√£o encontrado!`);
                return;
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;

            container.innerHTML = '';
            container.appendChild(alertDiv);

            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }

        // Ranking functions
        let rankingData = null;
        let registrationData = null;

        async function loadRanking() {
            try {
                setStatus('loading', 'Carregando ranking...');

                console.log('üîÑ Carregando ranking...');

                // Carregar ranking
                const rankingResponse = await fetch(getRankingURL(), {
                    headers: getRequestHeaders()
                });

                console.log('Ranking response status:', rankingResponse.status);

                if (!rankingResponse.ok) {
                    const errorText = await rankingResponse.text();
                    console.error('Erro ao carregar ranking:', errorText);
                    throw new Error(`Erro ao carregar ranking: ${rankingResponse.status}`);
                }

                rankingData = await rankingResponse.json();
                console.log('‚úÖ Ranking carregado:', rankingData);

                // Carregar registros
                const registrationResponse = await fetch(getRegistrationURL(), {
                    headers: getRequestHeaders()
                });

                console.log('Registration response status:', registrationResponse.status);

                if (!registrationResponse.ok) {
                    const errorText = await registrationResponse.text();
                    console.error('Erro ao carregar registros:', errorText);
                    throw new Error(`Erro ao carregar registros: ${registrationResponse.status}`);
                }

                registrationData = await registrationResponse.json();
                console.log('‚úÖ Registros carregados:', registrationData);

                displayRanking();
                setStatus('success', '‚úÖ Ranking carregado');

            } catch (error) {
                console.error('‚ùå Erro ao carregar ranking:', error);
                setStatus('error', '‚ùå Erro ao carregar ranking');
                showAlert('Erro ao carregar ranking: ' + error.message, 'error');
            }
        }

        function displayRanking() {
            const tbody = document.getElementById('rankingTableBody');

            if (!rankingData || !rankingData.entries || rankingData.entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 40px; color: #666;">
                            Nenhum jogador no ranking ainda.
                        </td>
                    </tr>
                `;
                updateRankingStats([]);
                return;
            }

            // Ordenar por pontua√ß√£o (desc) e depois por tempo (asc)
            const sortedEntries = [...rankingData.entries].sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                return a.totalTimeSeconds - b.totalTimeSeconds;
            });

            // Criar mapa de registros por ID para acesso r√°pido
            const registrationMap = {};
            if (registrationData && registrationData.players) {
                registrationData.players.forEach(player => {
                    registrationMap[player.id] = player;
                });
            }

            tbody.innerHTML = sortedEntries.map((entry, index) => {
                const registration = registrationMap[entry.id] || {};
                const position = index + 1;
                const medal = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : `${position}¬∫`;
                const timeFormatted = formatTime(entry.totalTimeSeconds);
                const phone = registration.ddd && registration.phone ? `(${registration.ddd}) ${registration.phone}` : '-';

                const rowColor = position === 1 ? '#fff9db' :
                                position === 2 ? '#f0f0f0' :
                                position === 3 ? '#ffe4cc' : 'white';

                return `
                    <tr style="background: ${rowColor}; border-bottom: 1px solid #e9ecef;">
                        <td style="padding: 15px; font-weight: bold; font-size: 18px;">${medal}</td>
                        <td style="padding: 15px;">${entry.playerName || registration.name || '-'}</td>
                        <td style="padding: 15px;">${registration.email || '-'}</td>
                        <td style="padding: 15px;">${phone}</td>
                        <td style="padding: 15px;">${registration.cargo || '-'}</td>
                        <td style="padding: 15px; text-align: center; font-weight: bold; color: #4facfe;">${entry.score}</td>
                        <td style="padding: 15px; text-align: center;">${timeFormatted}</td>
                    </tr>
                `;
            }).join('');

            updateRankingStats(sortedEntries);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function updateRankingStats(entries) {
            const statsDiv = document.getElementById('rankingStats');

            if (!entries || entries.length === 0) {
                statsDiv.innerHTML = '';
                return;
            }

            const totalPlayers = entries.length;
            const avgScore = (entries.reduce((sum, e) => sum + e.score, 0) / totalPlayers).toFixed(1);
            const avgTime = (entries.reduce((sum, e) => sum + e.totalTimeSeconds, 0) / totalPlayers).toFixed(1);
            const highestScore = entries[0].score;

            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${totalPlayers}</div>
                    <div class="stat-label">Total de Jogadores</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${highestScore}</div>
                    <div class="stat-label">Maior Pontua√ß√£o</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${avgScore}</div>
                    <div class="stat-label">Pontua√ß√£o M√©dia</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${formatTime(avgTime)}</div>
                    <div class="stat-label">Tempo M√©dio</div>
                </div>
            `;
        }

        function exportRankingToCSV() {
            if (!rankingData || !rankingData.entries || rankingData.entries.length === 0) {
                showAlert('Nenhum dado para exportar!', 'error');
                return;
            }

            // Ordenar por pontua√ß√£o
            const sortedEntries = [...rankingData.entries].sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return a.totalTimeSeconds - b.totalTimeSeconds;
            });

            // Criar mapa de registros
            const registrationMap = {};
            if (registrationData && registrationData.players) {
                registrationData.players.forEach(player => {
                    registrationMap[player.id] = player;
                });
            }

            // Cabe√ßalho do CSV
            let csv = 'Coloca√ß√£o,Nome,Email,Telefone,Cargo,Pontua√ß√£o,Tempo (segundos)\n';

            // Adicionar dados
            sortedEntries.forEach((entry, index) => {
                const registration = registrationMap[entry.id] || {};
                const position = index + 1;
                const phone = registration.ddd && registration.phone ? `(${registration.ddd}) ${registration.phone}` : '';

                csv += `${position},"${entry.playerName || registration.name || ''}","${registration.email || ''}","${phone}","${registration.cargo || ''}",${entry.score},${entry.totalTimeSeconds.toFixed(2)}\n`;
            });

            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `ranking_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showAlert('Ranking exportado com sucesso!', 'success');
        }
    </script>
</body>

</html>